(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* global AFRAME */\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\nconst SKETCHFAB_API_URL = 'https://api.sketchfab.com/v3/models/MODEL/download';\n\nconst zip = __webpack_require__(/*! ./lib/zip.js */ \"./lib/zip.js\").zip;\n\nwindow.zip = zip;\n\n__webpack_require__(/*! ./lib/zip-ext.js */ \"./lib/zip-ext.js\");\n\nzip.Inflater = __webpack_require__(/*! ./lib/inflate.js */ \"./lib/inflate.js\").Inflater; //zip.workerScriptsPath = '../../lib/';\n\nzip.useWebWorkers = false;\n/*\nzip.workerScripts = {\n  deflater: ['./lib/z-worker.js', './lib/deflate.js'],\n  inflater: ['./lib/z-worker.js', './lib/inflate.js'],\n};\n*/\n//https://sketchfab.com/developers/download-api/downloading-models/javascript\n\n/**\n * Sketchfab component for A-Frame.\n */\n\nAFRAME.registerComponent('sketchfab', {\n  schema: {\n    token: {\n      default: ''\n    },\n    src: {},\n    normalize: {\n      type: 'boolean',\n      default: true\n    }\n  },\n  multiple: false,\n  init: function () {\n    this.model = null;\n    this.loadSketchfabModel = this.loadSketchfabModel.bind(this);\n  },\n  update: function (oldData) {\n    const el = this.el;\n    const data = this.data;\n    if (!data.src || !data.token) return;\n    this.remove();\n    this.getGLTFUrl(data.src, data.token).then(this.loadSketchfabModel).then(gltfModel => {\n      console.log('loaded', gltfModel);\n      this.model = gltfModel.scene || gltfModel.scenes[0];\n      this.model.animations = gltfModel.animations;\n      el.setObject3D('mesh', this.model); //el.emit('model-loaded', {format: 'gltf', model: this.model})\n\n      if (data.normalize) {\n        this.normalize();\n      }\n\n      el.emit('model-loaded');\n    }).catch(err => {\n      console.error('ERROR loading Sketchfab model from \"' + data.src + '\" : ' + err);\n      el.emit('model-error', err);\n    });\n  },\n  normalize: function () {\n    const el = this.el;\n    const mesh = el.getObject3D('mesh'); //Normalize scene scale\n\n    var TARGET_SIZE = 1;\n    var bbox = new THREE.Box3().setFromObject(mesh);\n    var maxSide = Math.max(bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y, bbox.max.z - bbox.min.z);\n    var ratio = TARGET_SIZE / maxSide;\n    mesh.scale.set(ratio, ratio, ratio); //Center scene\n\n    var centerX = bbox.min.x * ratio * -1 - (bbox.max.x - bbox.min.x) / 2 * ratio;\n    var centerY = bbox.min.y * ratio * -1;\n    var centerZ = bbox.min.z * ratio * -1 - (bbox.max.z - bbox.min.z) / 2 * ratio;\n    mesh.translateX(centerX);\n    mesh.translateY(centerY);\n    mesh.translateZ(centerZ);\n    console.log(ratio, centerX, centerY, centerZ);\n    const span = 1;\n    const offset = new THREE.Vector3(); // data.offset?\n\n    const position = new THREE.Vector3();\n    const scale = new THREE.Vector3();\n    position.copy(el.object3D.position);\n    scale.copy(el.object3D.scale);\n    mesh.scale.set(1, 1, 1);\n    mesh.position.set(0, 0, 0);\n    mesh.updateMatrixWorld(true); // https://github.com/mrdoob/three.js/blob/master/src/core/Geometry.js#L367\n\n    const box = new THREE.Box3();\n    box.setFromObject(mesh);\n    const boundingSphere = new THREE.Sphere();\n    box.getBoundingSphere(boundingSphere);\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n    const s = (radius === 0 ? 1 : 1.0 / radius) * span;\n    mesh.traverse(child => {\n      if (child.isMesh) {\n        child.geometry.scale(s, s, s);\n        child.geometry.translate(-s * center.x + offset.x, -s * center.y + offset.y, -s * center.z + offset.z);\n        child.geometry.computeBoundingBox();\n        child.geometry.computeBoundingSphere();\n      }\n    });\n    mesh.scale.copy(scale);\n    mesh.position.copy(position);\n    mesh.updateMatrixWorld(true);\n    console.log('norm', s, box, center, radius);\n  },\n  _remove: function () {\n    if (this.model) this.el.removeObject3D('mesh');\n  },\n  remove: function () {\n    this._remove();\n  },\n  getGLTFUrl: function (id, token) {\n    const url = SKETCHFAB_API_URL.replace(/MODEL/, id);\n    const options = {\n      method: 'GET',\n      headers: {\n        Authorization: `Bearer ${token}`\n      },\n      mode: 'cors'\n    };\n    return fetch(url, options).then(response => {\n      return response.json().catch(error => {\n        // handle JSON parsing error\n        console.log('ERROR parsing Sketchfab server response JSON.\\nRequested Model: \"' + url + '\"\\nError: \"' + JSON.stringify(error) + '\"');\n        return Promise.reject('Sketchfab API server error. Check console for details.');\n      }).then(data => {\n        if (!data.gltf.url) {\n          return Promise.reject('Sketchfab API error', data);\n        }\n\n        console.log('loaded url', data);\n        return { ...data.gltf\n        };\n      });\n    });\n  },\n  loadSketchfabModel: function (data) {\n    const url = data.url;\n    const size = data.size;\n    return new Promise((resolve, reject) => {\n      this.download(url).then(assetMap => {\n        const loader = new THREE.GLTFLoader();\n        const _url = assetMap.modifiedAssets[assetMap.url];\n        loader.load(_url, resolve);\n      });\n    });\n  },\n  download: function (url) {\n    // https://labs.sketchfab.com/experiments/download-api/\n    return new Promise((resolve, reject) => {\n      var assetMap = {};\n      var gltfUrl = 'scene.gltf';\n\n      this._readZip(url).then(entries => {\n        return this._parseZip(entries);\n      }).then(assetMap => {\n        resolve(assetMap);\n      }).catch(reject);\n    });\n    /*\n    const manager = new THREE.LoadingManager();\n    return new Promise((resolve, reject) => {\n       const zipLoader = new THREE.ZipLoader()\n      //loader.setResponseType( 'arraybuffer' )\n      zipLoader.load(url).then(file => {\n        manager.setURLModifier(file.urlResolver);\n        const item = resolve(file.find( /\\.(gltf|glb)$/i )[ 0 ] );\n        console.log('zip loaded', file, item)\n        resolve(item);\n       }).then(file => {\n        console.log('file loaded', file)\n        const gltfLoader = new THREE.GLTFLoader(manager)\n        gltfLoader.load(file, (gltf) => {\n            console.log('gltf loaded', gltf)\n            resolve(gltf)\n        })\n      })\n    })\n    */\n  },\n  _readZip: function (url) {\n    return new Promise((resolve, reject) => {\n      var reader = new zip.HttpReader(url);\n      zip.createReader(reader, zipReader => {\n        zipReader.getEntries(resolve);\n      }, reject);\n    });\n  },\n  _parseZip: function (entries) {\n    const _parseZip = (resolve, reject) => {\n      var url;\n      var entry;\n      var promises = [];\n      var completedPromises = 0;\n      var promise;\n\n      for (var i = 0, l = entries.length; i < l; i++) {\n        entry = entries[i];\n\n        if (entry.directory === true) {\n          continue;\n        }\n\n        if (entry.filename.match(/\\.gltf$/)) {\n          url = entry.filename;\n        }\n\n        promise = this._saveEntryToBlob(entry);\n        promise.then(result => {\n          completedPromises++;\n          return result;\n        });\n        promises.push(promise);\n      }\n\n      if (!url) {\n        return reject('Can not find a .gltf file');\n      }\n\n      var blobsReady = Promise.all(promises);\n      blobsReady.then(blobs => {\n        var assets = blobs.reduce((acc, cur) => {\n          acc[cur.name] = cur.url;\n          return acc;\n        }, {});\n        var shouldRewriteAssetsURLs = true;\n\n        if (shouldRewriteAssetsURLs) {\n          var assetsPromise = this._rewriteAssetURLs(assets, url, blobs);\n\n          assetsPromise.then(modifiedAssets => {\n            resolve({\n              assets: assets,\n              originalAssets: Object.assign({}, assets),\n              modifiedAssets: modifiedAssets,\n              url: url\n            });\n          });\n        } else {\n          resolve({\n            assets: assets,\n            originalAssets: Object.assign({}, assets),\n            modifiedAssets: null,\n            url: url\n          });\n        }\n      });\n    };\n\n    return new Promise(_parseZip);\n  },\n  _rewriteAssetURLs: function (assets, gltfPath, blobs) {\n    return new Promise((resolve, reject) => {\n      var newAssets = Object.assign({}, assets);\n      var reader = new FileReader();\n      var gltfBlob = blobs.reduce((acc, cur) => {\n        if (cur.name === gltfPath) {\n          return cur;\n        }\n\n        return acc;\n      }, null);\n\n      if (!gltfBlob) {\n        return reject('Cannot rewrite glTF (glTF not found)');\n      }\n\n      reader.onload = () => {\n        try {\n          var json = JSON.parse(reader.result); // Replace original buffers and images by blob URLs\n\n          if (json.hasOwnProperty('buffers')) {\n            for (var i = 0; i < json.buffers.length; i++) {\n              json.buffers[i].uri = newAssets[json.buffers[i].uri];\n            }\n          }\n\n          if (json.hasOwnProperty('images')) {\n            for (var i = 0; i < json.images.length; i++) {\n              json.images[i].uri = newAssets[json.images[i].uri];\n            }\n          }\n\n          var fileContent = JSON.stringify(json, null, 2);\n          var updatedBlob = new Blob([fileContent], {\n            type: 'text/plain'\n          });\n          var gltfBlobUrl = window.URL.createObjectURL(updatedBlob);\n          newAssets[gltfPath] = gltfBlobUrl;\n          resolve(newAssets);\n        } catch (e) {\n          reject('Cannot parse glTF file', e);\n        }\n      };\n\n      reader.readAsText(gltfBlob.blob);\n    });\n  },\n  _saveEntryToBlob: function (entry) {\n    return new Promise((resolve, reject) => {\n      entry.getData(new zip.BlobWriter('text/plain'), data => {\n        var url = window.URL.createObjectURL(data);\n        resolve({\n          name: entry.filename,\n          url: url,\n          blob: data\n        });\n      });\n    });\n  }\n});\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./lib/inflate.js":
/*!************************!*\
  !*** ./lib/inflate.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.\n * JZlib is based on zlib-1.1.3, so all credit should go authors\n * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)\n * and contributors of zlib.\n */\n(function (global) {\n  \"use strict\"; // Global\n\n  var MAX_BITS = 15;\n  var Z_OK = 0;\n  var Z_STREAM_END = 1;\n  var Z_NEED_DICT = 2;\n  var Z_STREAM_ERROR = -2;\n  var Z_DATA_ERROR = -3;\n  var Z_MEM_ERROR = -4;\n  var Z_BUF_ERROR = -5;\n  var inflate_mask = [0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff];\n  var MANY = 1440; // JZlib version : \"1.0.2\"\n\n  var Z_NO_FLUSH = 0;\n  var Z_FINISH = 4; // InfTree\n\n  var fixed_bl = 9;\n  var fixed_bd = 5;\n  var fixed_tl = [96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255];\n  var fixed_td = [80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5, 8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5, 24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577]; // Tables for deflate from PKZIP's appnote.txt.\n\n  var cplens = [// Copy lengths for literal codes 257..285\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]; // see note #13 above about 258\n\n  var cplext = [// Extra bits for literal codes 257..285\n  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid\n  ];\n  var cpdist = [// Copy offsets for distance codes 0..29\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];\n  var cpdext = [// Extra bits for distance codes\n  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]; // If BMAX needs to be larger than 16, then h and x[] should be uLong.\n\n  var BMAX = 15; // maximum bit length of any code\n\n  function InfTree() {\n    var that = this;\n    var hn; // hufts used in space\n\n    var v; // work area for huft_build\n\n    var c; // bit length count table\n\n    var r; // table entry for structure assignment\n\n    var u; // table stack\n\n    var x; // bit offsets, then code stack\n\n    function huft_build(b, // code lengths in bits (all assumed <=\n    // BMAX)\n    bindex, n, // number of codes (assumed <= 288)\n    s, // number of simple-valued codes (0..s-1)\n    d, // list of base values for non-simple codes\n    e, // list of extra bits for non-simple codes\n    t, // result: starting table\n    m, // maximum lookup bits, returns actual\n    hp, // space for trees\n    hn, // hufts used in space\n    v // working area: values in order of bit length\n    ) {\n      // Given a list of code lengths and a maximum table size, make a set of\n      // tables to decode that set of codes. Return Z_OK on success,\n      // Z_BUF_ERROR\n      // if the given code set is incomplete (the tables are still built in\n      // this\n      // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set\n      // of\n      // lengths), or Z_MEM_ERROR if not enough memory.\n      var a; // counter for codes of length k\n\n      var f; // i repeats in table every f entries\n\n      var g; // maximum code length\n\n      var h; // table level\n\n      var i; // counter, current code\n\n      var j; // counter\n\n      var k; // number of bits in current code\n\n      var l; // bits per table (returned in m)\n\n      var mask; // (1 << w) - 1, to avoid cc -O bug on HP\n\n      var p; // pointer into c[], b[], or v[]\n\n      var q; // points to current table\n\n      var w; // bits before this table == (l * h)\n\n      var xp; // pointer into x\n\n      var y; // number of dummy codes added\n\n      var z; // number of entries in current table\n      // Generate counts for each bit length\n\n      p = 0;\n      i = n;\n\n      do {\n        c[b[bindex + p]]++;\n        p++;\n        i--; // assume all entries <= BMAX\n      } while (i !== 0);\n\n      if (c[0] == n) {\n        // null input--all zero length codes\n        t[0] = -1;\n        m[0] = 0;\n        return Z_OK;\n      } // Find minimum and maximum length, bound *m by those\n\n\n      l = m[0];\n\n      for (j = 1; j <= BMAX; j++) if (c[j] !== 0) break;\n\n      k = j; // minimum code length\n\n      if (l < j) {\n        l = j;\n      }\n\n      for (i = BMAX; i !== 0; i--) {\n        if (c[i] !== 0) break;\n      }\n\n      g = i; // maximum code length\n\n      if (l > i) {\n        l = i;\n      }\n\n      m[0] = l; // Adjust last length count to fill out codes, if needed\n\n      for (y = 1 << j; j < i; j++, y <<= 1) {\n        if ((y -= c[j]) < 0) {\n          return Z_DATA_ERROR;\n        }\n      }\n\n      if ((y -= c[i]) < 0) {\n        return Z_DATA_ERROR;\n      }\n\n      c[i] += y; // Generate starting offsets into the value table for each length\n\n      x[1] = j = 0;\n      p = 1;\n      xp = 2;\n\n      while (--i !== 0) {\n        // note that i == g from above\n        x[xp] = j += c[p];\n        xp++;\n        p++;\n      } // Make a table of values in order of bit lengths\n\n\n      i = 0;\n      p = 0;\n\n      do {\n        if ((j = b[bindex + p]) !== 0) {\n          v[x[j]++] = i;\n        }\n\n        p++;\n      } while (++i < n);\n\n      n = x[g]; // set n to length of v\n      // Generate the Huffman codes and for each, make the table entries\n\n      x[0] = i = 0; // first Huffman code is zero\n\n      p = 0; // grab values in bit order\n\n      h = -1; // no tables yet--level -1\n\n      w = -l; // bits decoded == (l * h)\n\n      u[0] = 0; // just to keep compilers happy\n\n      q = 0; // ditto\n\n      z = 0; // ditto\n      // go through the bit lengths (k already is bits in shortest code)\n\n      for (; k <= g; k++) {\n        a = c[k];\n\n        while (a-- !== 0) {\n          // here i is the Huffman code of length k bits for value *p\n          // make tables up to required level\n          while (k > w + l) {\n            h++;\n            w += l; // previous table always l bits\n            // compute minimum size table less than or equal to l bits\n\n            z = g - w;\n            z = z > l ? l : z; // table size upper limit\n\n            if ((f = 1 << (j = k - w)) > a + 1) {\n              // try a k-w bit table\n              // too few codes for\n              // k-w bit table\n              f -= a + 1; // deduct codes from patterns left\n\n              xp = k;\n\n              if (j < z) {\n                while (++j < z) {\n                  // try smaller tables up to z bits\n                  if ((f <<= 1) <= c[++xp]) break; // enough codes to use up j bits\n\n                  f -= c[xp]; // else deduct codes from patterns\n                }\n              }\n            }\n\n            z = 1 << j; // table entries for j-bit table\n            // allocate new table\n\n            if (hn[0] + z > MANY) {\n              // (note: doesn't matter for fixed)\n              return Z_DATA_ERROR; // overflow of MANY\n            }\n\n            u[h] = q =\n            /* hp+ */\n            hn[0]; // DEBUG\n\n            hn[0] += z; // connect to last table, if there is one\n\n            if (h !== 0) {\n              x[h] = i; // save pattern for backing up\n\n              r[0] =\n              /* (byte) */\n              j; // bits in this table\n\n              r[1] =\n              /* (byte) */\n              l; // bits to dump before this table\n\n              j = i >>> w - l;\n              r[2] =\n              /* (int) */\n              q - u[h - 1] - j; // offset to this table\n\n              hp.set(r, (u[h - 1] + j) * 3); // to\n              // last\n              // table\n            } else {\n              t[0] = q; // first table is returned result\n            }\n          } // set up table entry in r\n\n\n          r[1] =\n          /* (byte) */\n          k - w;\n\n          if (p >= n) {\n            r[0] = 128 + 64; // out of values--invalid code\n          } else if (v[p] < s) {\n            r[0] =\n            /* (byte) */\n            v[p] < 256 ? 0 : 32 + 64; // 256 is\n            // end-of-block\n\n            r[2] = v[p++]; // simple code is just the value\n          } else {\n            r[0] =\n            /* (byte) */\n            e[v[p] - s] + 16 + 64; // non-simple--look\n            // up in lists\n\n            r[2] = d[v[p++] - s];\n          } // fill code-like entries with r\n\n\n          f = 1 << k - w;\n\n          for (j = i >>> w; j < z; j += f) {\n            hp.set(r, (q + j) * 3);\n          } // backwards increment the k-bit code i\n\n\n          for (j = 1 << k - 1; (i & j) !== 0; j >>>= 1) {\n            i ^= j;\n          }\n\n          i ^= j; // backup over finished tables\n\n          mask = (1 << w) - 1; // needed on HP, cc -O bug\n\n          while ((i & mask) != x[h]) {\n            h--; // don't need to update q\n\n            w -= l;\n            mask = (1 << w) - 1;\n          }\n        }\n      } // Return Z_BUF_ERROR if we were given an incomplete table\n\n\n      return y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n    }\n\n    function initWorkArea(vsize) {\n      var i;\n\n      if (!hn) {\n        hn = []; // []; //new Array(1);\n\n        v = []; // new Array(vsize);\n\n        c = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\n\n        r = []; // new Array(3);\n\n        u = new Int32Array(BMAX); // new Array(BMAX);\n\n        x = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\n      }\n\n      if (v.length < vsize) {\n        v = []; // new Array(vsize);\n      }\n\n      for (i = 0; i < vsize; i++) {\n        v[i] = 0;\n      }\n\n      for (i = 0; i < BMAX + 1; i++) {\n        c[i] = 0;\n      }\n\n      for (i = 0; i < 3; i++) {\n        r[i] = 0;\n      } // for(int i=0; i<BMAX; i++){u[i]=0;}\n\n\n      u.set(c.subarray(0, BMAX), 0); // for(int i=0; i<BMAX+1; i++){x[i]=0;}\n\n      x.set(c.subarray(0, BMAX + 1), 0);\n    }\n\n    that.inflate_trees_bits = function (c, // 19 code lengths\n    bb, // bits tree desired/actual depth\n    tb, // bits tree result\n    hp, // space for trees\n    z // for messages\n    ) {\n      var result;\n      initWorkArea(19);\n      hn[0] = 0;\n      result = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);\n\n      if (result == Z_DATA_ERROR) {\n        z.msg = \"oversubscribed dynamic bit lengths tree\";\n      } else if (result == Z_BUF_ERROR || bb[0] === 0) {\n        z.msg = \"incomplete dynamic bit lengths tree\";\n        result = Z_DATA_ERROR;\n      }\n\n      return result;\n    };\n\n    that.inflate_trees_dynamic = function (nl, // number of literal/length codes\n    nd, // number of distance codes\n    c, // that many (total) code lengths\n    bl, // literal desired/actual bit depth\n    bd, // distance desired/actual bit depth\n    tl, // literal/length tree result\n    td, // distance tree result\n    hp, // space for trees\n    z // for messages\n    ) {\n      var result; // build literal/length tree\n\n      initWorkArea(288);\n      hn[0] = 0;\n      result = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);\n\n      if (result != Z_OK || bl[0] === 0) {\n        if (result == Z_DATA_ERROR) {\n          z.msg = \"oversubscribed literal/length tree\";\n        } else if (result != Z_MEM_ERROR) {\n          z.msg = \"incomplete literal/length tree\";\n          result = Z_DATA_ERROR;\n        }\n\n        return result;\n      } // build distance tree\n\n\n      initWorkArea(288);\n      result = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);\n\n      if (result != Z_OK || bd[0] === 0 && nl > 257) {\n        if (result == Z_DATA_ERROR) {\n          z.msg = \"oversubscribed distance tree\";\n        } else if (result == Z_BUF_ERROR) {\n          z.msg = \"incomplete distance tree\";\n          result = Z_DATA_ERROR;\n        } else if (result != Z_MEM_ERROR) {\n          z.msg = \"empty distance tree with lengths\";\n          result = Z_DATA_ERROR;\n        }\n\n        return result;\n      }\n\n      return Z_OK;\n    };\n  }\n\n  InfTree.inflate_trees_fixed = function (bl, // literal desired/actual bit depth\n  bd, // distance desired/actual bit depth\n  tl, // literal/length tree result\n  td // distance tree result\n  ) {\n    bl[0] = fixed_bl;\n    bd[0] = fixed_bd;\n    tl[0] = fixed_tl;\n    td[0] = fixed_td;\n    return Z_OK;\n  }; // InfCodes\n  // waiting for \"i:\"=input,\n  // \"o:\"=output,\n  // \"x:\"=nothing\n\n\n  var START = 0; // x: set up for LEN\n\n  var LEN = 1; // i: get length/literal/eob next\n\n  var LENEXT = 2; // i: getting length extra (have base)\n\n  var DIST = 3; // i: get distance next\n\n  var DISTEXT = 4; // i: getting distance extra\n\n  var COPY = 5; // o: copying bytes in window, waiting\n  // for space\n\n  var LIT = 6; // o: got literal, waiting for output\n  // space\n\n  var WASH = 7; // o: got eob, possibly still output\n  // waiting\n\n  var END = 8; // x: got eob and all data flushed\n\n  var BADCODE = 9; // x: got error\n\n  function InfCodes() {\n    var that = this;\n    var mode; // current inflate_codes mode\n    // mode dependent information\n\n    var len = 0;\n    var tree; // pointer into tree\n\n    var tree_index = 0;\n    var need = 0; // bits needed\n\n    var lit = 0; // if EXT or COPY, where and how much\n\n    var get = 0; // bits to get for extra\n\n    var dist = 0; // distance back to copy from\n\n    var lbits = 0; // ltree bits decoded per branch\n\n    var dbits = 0; // dtree bits decoder per branch\n\n    var ltree; // literal/length/eob tree\n\n    var ltree_index = 0; // literal/length/eob tree\n\n    var dtree; // distance tree\n\n    var dtree_index = 0; // distance tree\n    // Called with number of bytes left to write in window at least 258\n    // (the maximum string length) and number of input bytes available\n    // at least ten. The ten bytes are six bytes for the longest length/\n    // distance pair plus four bytes for overloading the bit buffer.\n\n    function inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {\n      var t; // temporary pointer\n\n      var tp; // temporary pointer\n\n      var tp_index; // temporary pointer\n\n      var e; // extra bits or operation\n\n      var b; // bit buffer\n\n      var k; // bits in bit buffer\n\n      var p; // input data pointer\n\n      var n; // bytes available there\n\n      var q; // output window write pointer\n\n      var m; // bytes to end of window or read pointer\n\n      var ml; // mask for literal/length tree\n\n      var md; // mask for distance tree\n\n      var c; // bytes to copy\n\n      var d; // distance back to copy from\n\n      var r; // copy source pointer\n\n      var tp_index_t_3; // (tp_index+t)*3\n      // load input, output, bit values\n\n      p = z.next_in_index;\n      n = z.avail_in;\n      b = s.bitb;\n      k = s.bitk;\n      q = s.write;\n      m = q < s.read ? s.read - q - 1 : s.end - q; // initialize masks\n\n      ml = inflate_mask[bl];\n      md = inflate_mask[bd]; // do until not enough input or output space for fast loop\n\n      do {\n        // assume called with m >= 258 && n >= 10\n        // get literal/length code\n        while (k < 20) {\n          // max bits for literal/length code\n          n--;\n          b |= (z.read_byte(p++) & 0xff) << k;\n          k += 8;\n        }\n\n        t = b & ml;\n        tp = tl;\n        tp_index = tl_index;\n        tp_index_t_3 = (tp_index + t) * 3;\n\n        if ((e = tp[tp_index_t_3]) === 0) {\n          b >>= tp[tp_index_t_3 + 1];\n          k -= tp[tp_index_t_3 + 1];\n          s.window[q++] =\n          /* (byte) */\n          tp[tp_index_t_3 + 2];\n          m--;\n          continue;\n        }\n\n        do {\n          b >>= tp[tp_index_t_3 + 1];\n          k -= tp[tp_index_t_3 + 1];\n\n          if ((e & 16) !== 0) {\n            e &= 15;\n            c = tp[tp_index_t_3 + 2] + (\n            /* (int) */\n            b & inflate_mask[e]);\n            b >>= e;\n            k -= e; // decode distance base of block to copy\n\n            while (k < 15) {\n              // max bits for distance code\n              n--;\n              b |= (z.read_byte(p++) & 0xff) << k;\n              k += 8;\n            }\n\n            t = b & md;\n            tp = td;\n            tp_index = td_index;\n            tp_index_t_3 = (tp_index + t) * 3;\n            e = tp[tp_index_t_3];\n\n            do {\n              b >>= tp[tp_index_t_3 + 1];\n              k -= tp[tp_index_t_3 + 1];\n\n              if ((e & 16) !== 0) {\n                // get extra bits to add to distance base\n                e &= 15;\n\n                while (k < e) {\n                  // get extra bits (up to 13)\n                  n--;\n                  b |= (z.read_byte(p++) & 0xff) << k;\n                  k += 8;\n                }\n\n                d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);\n                b >>= e;\n                k -= e; // do the copy\n\n                m -= c;\n\n                if (q >= d) {\n                  // offset before dest\n                  // just copy\n                  r = q - d;\n\n                  if (q - r > 0 && 2 > q - r) {\n                    s.window[q++] = s.window[r++]; // minimum\n                    // count is\n                    // three,\n\n                    s.window[q++] = s.window[r++]; // so unroll\n                    // loop a\n                    // little\n\n                    c -= 2;\n                  } else {\n                    s.window.set(s.window.subarray(r, r + 2), q);\n                    q += 2;\n                    r += 2;\n                    c -= 2;\n                  }\n                } else {\n                  // else offset after destination\n                  r = q - d;\n\n                  do {\n                    r += s.end; // force pointer in window\n                  } while (r < 0); // covers invalid distances\n\n\n                  e = s.end - r;\n\n                  if (c > e) {\n                    // if source crosses,\n                    c -= e; // wrapped copy\n\n                    if (q - r > 0 && e > q - r) {\n                      do {\n                        s.window[q++] = s.window[r++];\n                      } while (--e !== 0);\n                    } else {\n                      s.window.set(s.window.subarray(r, r + e), q);\n                      q += e;\n                      r += e;\n                      e = 0;\n                    }\n\n                    r = 0; // copy rest from start of window\n                  }\n                } // copy all or what's left\n\n\n                if (q - r > 0 && c > q - r) {\n                  do {\n                    s.window[q++] = s.window[r++];\n                  } while (--c !== 0);\n                } else {\n                  s.window.set(s.window.subarray(r, r + c), q);\n                  q += c;\n                  r += c;\n                  c = 0;\n                }\n\n                break;\n              } else if ((e & 64) === 0) {\n                t += tp[tp_index_t_3 + 2];\n                t += b & inflate_mask[e];\n                tp_index_t_3 = (tp_index + t) * 3;\n                e = tp[tp_index_t_3];\n              } else {\n                z.msg = \"invalid distance code\";\n                c = z.avail_in - n;\n                c = k >> 3 < c ? k >> 3 : c;\n                n += c;\n                p -= c;\n                k -= c << 3;\n                s.bitb = b;\n                s.bitk = k;\n                z.avail_in = n;\n                z.total_in += p - z.next_in_index;\n                z.next_in_index = p;\n                s.write = q;\n                return Z_DATA_ERROR;\n              }\n            } while (true);\n\n            break;\n          }\n\n          if ((e & 64) === 0) {\n            t += tp[tp_index_t_3 + 2];\n            t += b & inflate_mask[e];\n            tp_index_t_3 = (tp_index + t) * 3;\n\n            if ((e = tp[tp_index_t_3]) === 0) {\n              b >>= tp[tp_index_t_3 + 1];\n              k -= tp[tp_index_t_3 + 1];\n              s.window[q++] =\n              /* (byte) */\n              tp[tp_index_t_3 + 2];\n              m--;\n              break;\n            }\n          } else if ((e & 32) !== 0) {\n            c = z.avail_in - n;\n            c = k >> 3 < c ? k >> 3 : c;\n            n += c;\n            p -= c;\n            k -= c << 3;\n            s.bitb = b;\n            s.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;\n            z.next_in_index = p;\n            s.write = q;\n            return Z_STREAM_END;\n          } else {\n            z.msg = \"invalid literal/length code\";\n            c = z.avail_in - n;\n            c = k >> 3 < c ? k >> 3 : c;\n            n += c;\n            p -= c;\n            k -= c << 3;\n            s.bitb = b;\n            s.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;\n            z.next_in_index = p;\n            s.write = q;\n            return Z_DATA_ERROR;\n          }\n        } while (true);\n      } while (m >= 258 && n >= 10); // not enough input or output--restore pointers and return\n\n\n      c = z.avail_in - n;\n      c = k >> 3 < c ? k >> 3 : c;\n      n += c;\n      p -= c;\n      k -= c << 3;\n      s.bitb = b;\n      s.bitk = k;\n      z.avail_in = n;\n      z.total_in += p - z.next_in_index;\n      z.next_in_index = p;\n      s.write = q;\n      return Z_OK;\n    }\n\n    that.init = function (bl, bd, tl, tl_index, td, td_index) {\n      mode = START;\n      lbits =\n      /* (byte) */\n      bl;\n      dbits =\n      /* (byte) */\n      bd;\n      ltree = tl;\n      ltree_index = tl_index;\n      dtree = td;\n      dtree_index = td_index;\n      tree = null;\n    };\n\n    that.proc = function (s, z, r) {\n      var j; // temporary storage\n\n      var tindex; // temporary pointer\n\n      var e; // extra bits or operation\n\n      var b = 0; // bit buffer\n\n      var k = 0; // bits in bit buffer\n\n      var p = 0; // input data pointer\n\n      var n; // bytes available there\n\n      var q; // output window write pointer\n\n      var m; // bytes to end of window or read pointer\n\n      var f; // pointer to copy strings from\n      // copy input/output information to locals (UPDATE macro restores)\n\n      p = z.next_in_index;\n      n = z.avail_in;\n      b = s.bitb;\n      k = s.bitk;\n      q = s.write;\n      m = q < s.read ? s.read - q - 1 : s.end - q; // process input and output based on current state\n\n      while (true) {\n        switch (mode) {\n          // waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\n          case START:\n            // x: set up for LEN\n            if (m >= 258 && n >= 10) {\n              s.bitb = b;\n              s.bitk = k;\n              z.avail_in = n;\n              z.total_in += p - z.next_in_index;\n              z.next_in_index = p;\n              s.write = q;\n              r = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);\n              p = z.next_in_index;\n              n = z.avail_in;\n              b = s.bitb;\n              k = s.bitk;\n              q = s.write;\n              m = q < s.read ? s.read - q - 1 : s.end - q;\n\n              if (r != Z_OK) {\n                mode = r == Z_STREAM_END ? WASH : BADCODE;\n                break;\n              }\n            }\n\n            need = lbits;\n            tree = ltree;\n            tree_index = ltree_index;\n            mode = LEN;\n\n          /* falls through */\n\n          case LEN:\n            // i: get length/literal/eob next\n            j = need;\n\n            while (k < j) {\n              if (n !== 0) r = Z_OK;else {\n                s.bitb = b;\n                s.bitk = k;\n                z.avail_in = n;\n                z.total_in += p - z.next_in_index;\n                z.next_in_index = p;\n                s.write = q;\n                return s.inflate_flush(z, r);\n              }\n              n--;\n              b |= (z.read_byte(p++) & 0xff) << k;\n              k += 8;\n            }\n\n            tindex = (tree_index + (b & inflate_mask[j])) * 3;\n            b >>>= tree[tindex + 1];\n            k -= tree[tindex + 1];\n            e = tree[tindex];\n\n            if (e === 0) {\n              // literal\n              lit = tree[tindex + 2];\n              mode = LIT;\n              break;\n            }\n\n            if ((e & 16) !== 0) {\n              // length\n              get = e & 15;\n              len = tree[tindex + 2];\n              mode = LENEXT;\n              break;\n            }\n\n            if ((e & 64) === 0) {\n              // next table\n              need = e;\n              tree_index = tindex / 3 + tree[tindex + 2];\n              break;\n            }\n\n            if ((e & 32) !== 0) {\n              // end of block\n              mode = WASH;\n              break;\n            }\n\n            mode = BADCODE; // invalid code\n\n            z.msg = \"invalid literal/length code\";\n            r = Z_DATA_ERROR;\n            s.bitb = b;\n            s.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;\n            z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n\n          case LENEXT:\n            // i: getting length extra (have base)\n            j = get;\n\n            while (k < j) {\n              if (n !== 0) r = Z_OK;else {\n                s.bitb = b;\n                s.bitk = k;\n                z.avail_in = n;\n                z.total_in += p - z.next_in_index;\n                z.next_in_index = p;\n                s.write = q;\n                return s.inflate_flush(z, r);\n              }\n              n--;\n              b |= (z.read_byte(p++) & 0xff) << k;\n              k += 8;\n            }\n\n            len += b & inflate_mask[j];\n            b >>= j;\n            k -= j;\n            need = dbits;\n            tree = dtree;\n            tree_index = dtree_index;\n            mode = DIST;\n\n          /* falls through */\n\n          case DIST:\n            // i: get distance next\n            j = need;\n\n            while (k < j) {\n              if (n !== 0) r = Z_OK;else {\n                s.bitb = b;\n                s.bitk = k;\n                z.avail_in = n;\n                z.total_in += p - z.next_in_index;\n                z.next_in_index = p;\n                s.write = q;\n                return s.inflate_flush(z, r);\n              }\n              n--;\n              b |= (z.read_byte(p++) & 0xff) << k;\n              k += 8;\n            }\n\n            tindex = (tree_index + (b & inflate_mask[j])) * 3;\n            b >>= tree[tindex + 1];\n            k -= tree[tindex + 1];\n            e = tree[tindex];\n\n            if ((e & 16) !== 0) {\n              // distance\n              get = e & 15;\n              dist = tree[tindex + 2];\n              mode = DISTEXT;\n              break;\n            }\n\n            if ((e & 64) === 0) {\n              // next table\n              need = e;\n              tree_index = tindex / 3 + tree[tindex + 2];\n              break;\n            }\n\n            mode = BADCODE; // invalid code\n\n            z.msg = \"invalid distance code\";\n            r = Z_DATA_ERROR;\n            s.bitb = b;\n            s.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;\n            z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n\n          case DISTEXT:\n            // i: getting distance extra\n            j = get;\n\n            while (k < j) {\n              if (n !== 0) r = Z_OK;else {\n                s.bitb = b;\n                s.bitk = k;\n                z.avail_in = n;\n                z.total_in += p - z.next_in_index;\n                z.next_in_index = p;\n                s.write = q;\n                return s.inflate_flush(z, r);\n              }\n              n--;\n              b |= (z.read_byte(p++) & 0xff) << k;\n              k += 8;\n            }\n\n            dist += b & inflate_mask[j];\n            b >>= j;\n            k -= j;\n            mode = COPY;\n\n          /* falls through */\n\n          case COPY:\n            // o: copying bytes in window, waiting for space\n            f = q - dist;\n\n            while (f < 0) {\n              // modulo window size-\"while\" instead\n              f += s.end; // of \"if\" handles invalid distances\n            }\n\n            while (len !== 0) {\n              if (m === 0) {\n                if (q == s.end && s.read !== 0) {\n                  q = 0;\n                  m = q < s.read ? s.read - q - 1 : s.end - q;\n                }\n\n                if (m === 0) {\n                  s.write = q;\n                  r = s.inflate_flush(z, r);\n                  q = s.write;\n                  m = q < s.read ? s.read - q - 1 : s.end - q;\n\n                  if (q == s.end && s.read !== 0) {\n                    q = 0;\n                    m = q < s.read ? s.read - q - 1 : s.end - q;\n                  }\n\n                  if (m === 0) {\n                    s.bitb = b;\n                    s.bitk = k;\n                    z.avail_in = n;\n                    z.total_in += p - z.next_in_index;\n                    z.next_in_index = p;\n                    s.write = q;\n                    return s.inflate_flush(z, r);\n                  }\n                }\n              }\n\n              s.window[q++] = s.window[f++];\n              m--;\n              if (f == s.end) f = 0;\n              len--;\n            }\n\n            mode = START;\n            break;\n\n          case LIT:\n            // o: got literal, waiting for output space\n            if (m === 0) {\n              if (q == s.end && s.read !== 0) {\n                q = 0;\n                m = q < s.read ? s.read - q - 1 : s.end - q;\n              }\n\n              if (m === 0) {\n                s.write = q;\n                r = s.inflate_flush(z, r);\n                q = s.write;\n                m = q < s.read ? s.read - q - 1 : s.end - q;\n\n                if (q == s.end && s.read !== 0) {\n                  q = 0;\n                  m = q < s.read ? s.read - q - 1 : s.end - q;\n                }\n\n                if (m === 0) {\n                  s.bitb = b;\n                  s.bitk = k;\n                  z.avail_in = n;\n                  z.total_in += p - z.next_in_index;\n                  z.next_in_index = p;\n                  s.write = q;\n                  return s.inflate_flush(z, r);\n                }\n              }\n            }\n\n            r = Z_OK;\n            s.window[q++] =\n            /* (byte) */\n            lit;\n            m--;\n            mode = START;\n            break;\n\n          case WASH:\n            // o: got eob, possibly more output\n            if (k > 7) {\n              // return unused byte, if any\n              k -= 8;\n              n++;\n              p--; // can always return one\n            }\n\n            s.write = q;\n            r = s.inflate_flush(z, r);\n            q = s.write;\n            m = q < s.read ? s.read - q - 1 : s.end - q;\n\n            if (s.read != s.write) {\n              s.bitb = b;\n              s.bitk = k;\n              z.avail_in = n;\n              z.total_in += p - z.next_in_index;\n              z.next_in_index = p;\n              s.write = q;\n              return s.inflate_flush(z, r);\n            }\n\n            mode = END;\n\n          /* falls through */\n\n          case END:\n            r = Z_STREAM_END;\n            s.bitb = b;\n            s.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;\n            z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n\n          case BADCODE:\n            // x: got error\n            r = Z_DATA_ERROR;\n            s.bitb = b;\n            s.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;\n            z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n\n          default:\n            r = Z_STREAM_ERROR;\n            s.bitb = b;\n            s.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;\n            z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n        }\n      }\n    };\n\n    that.free = function () {// ZFREE(z, c);\n    };\n  } // InfBlocks\n  // Table for deflate from PKZIP's appnote.txt.\n\n\n  var border = [// Order of the bit length code lengths\n  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n  var TYPE = 0; // get type bits (3, including end bit)\n\n  var LENS = 1; // get lengths for stored\n\n  var STORED = 2; // processing stored block\n\n  var TABLE = 3; // get table lengths\n\n  var BTREE = 4; // get bit lengths tree for a dynamic\n  // block\n\n  var DTREE = 5; // get length, distance trees for a\n  // dynamic block\n\n  var CODES = 6; // processing fixed or dynamic block\n\n  var DRY = 7; // output remaining window bytes\n\n  var DONELOCKS = 8; // finished last block, done\n\n  var BADBLOCKS = 9; // ot a data error--stuck here\n\n  function InfBlocks(z, w) {\n    var that = this;\n    var mode = TYPE; // current inflate_block mode\n\n    var left = 0; // if STORED, bytes left to copy\n\n    var table = 0; // table lengths (14 bits)\n\n    var index = 0; // index into blens (or border)\n\n    var blens; // bit lengths of codes\n\n    var bb = [0]; // bit length tree depth\n\n    var tb = [0]; // bit length decoding tree\n\n    var codes = new InfCodes(); // if CODES, current state\n\n    var last = 0; // true if this block is the last block\n\n    var hufts = new Int32Array(MANY * 3); // single malloc for tree space\n\n    var check = 0; // check on output\n\n    var inftree = new InfTree();\n    that.bitk = 0; // bits in bit buffer\n\n    that.bitb = 0; // bit buffer\n\n    that.window = new Uint8Array(w); // sliding window\n\n    that.end = w; // one byte after sliding window\n\n    that.read = 0; // window read pointer\n\n    that.write = 0; // window write pointer\n\n    that.reset = function (z, c) {\n      if (c) c[0] = check; // if (mode == BTREE || mode == DTREE) {\n      // }\n\n      if (mode == CODES) {\n        codes.free(z);\n      }\n\n      mode = TYPE;\n      that.bitk = 0;\n      that.bitb = 0;\n      that.read = that.write = 0;\n    };\n\n    that.reset(z, null); // copy as much as possible from the sliding window to the output area\n\n    that.inflate_flush = function (z, r) {\n      var n;\n      var p;\n      var q; // local copies of source and destination pointers\n\n      p = z.next_out_index;\n      q = that.read; // compute number of bytes to copy as far as end of window\n\n      n =\n      /* (int) */\n      (q <= that.write ? that.write : that.end) - q;\n      if (n > z.avail_out) n = z.avail_out;\n      if (n !== 0 && r == Z_BUF_ERROR) r = Z_OK; // update counters\n\n      z.avail_out -= n;\n      z.total_out += n; // copy as far as end of window\n\n      z.next_out.set(that.window.subarray(q, q + n), p);\n      p += n;\n      q += n; // see if more to copy at beginning of window\n\n      if (q == that.end) {\n        // wrap pointers\n        q = 0;\n        if (that.write == that.end) that.write = 0; // compute bytes to copy\n\n        n = that.write - q;\n        if (n > z.avail_out) n = z.avail_out;\n        if (n !== 0 && r == Z_BUF_ERROR) r = Z_OK; // update counters\n\n        z.avail_out -= n;\n        z.total_out += n; // copy\n\n        z.next_out.set(that.window.subarray(q, q + n), p);\n        p += n;\n        q += n;\n      } // update pointers\n\n\n      z.next_out_index = p;\n      that.read = q; // done\n\n      return r;\n    };\n\n    that.proc = function (z, r) {\n      var t; // temporary storage\n\n      var b; // bit buffer\n\n      var k; // bits in bit buffer\n\n      var p; // input data pointer\n\n      var n; // bytes available there\n\n      var q; // output window write pointer\n\n      var m; // bytes to end of window or read pointer\n\n      var i; // copy input/output information to locals (UPDATE macro restores)\n      // {\n\n      p = z.next_in_index;\n      n = z.avail_in;\n      b = that.bitb;\n      k = that.bitk; // }\n      // {\n\n      q = that.write;\n      m =\n      /* (int) */\n      q < that.read ? that.read - q - 1 : that.end - q; // }\n      // process input based on current state\n      // DEBUG dtree\n\n      while (true) {\n        switch (mode) {\n          case TYPE:\n            while (k < 3) {\n              if (n !== 0) {\n                r = Z_OK;\n              } else {\n                that.bitb = b;\n                that.bitk = k;\n                z.avail_in = n;\n                z.total_in += p - z.next_in_index;\n                z.next_in_index = p;\n                that.write = q;\n                return that.inflate_flush(z, r);\n              }\n\n              n--;\n              b |= (z.read_byte(p++) & 0xff) << k;\n              k += 8;\n            }\n\n            t =\n            /* (int) */\n            b & 7;\n            last = t & 1;\n\n            switch (t >>> 1) {\n              case 0:\n                // stored\n                // {\n                b >>>= 3;\n                k -= 3; // }\n\n                t = k & 7; // go to byte boundary\n                // {\n\n                b >>>= t;\n                k -= t; // }\n\n                mode = LENS; // get length of stored block\n\n                break;\n\n              case 1:\n                // fixed\n                // {\n                var bl = []; // new Array(1);\n\n                var bd = []; // new Array(1);\n\n                var tl = [[]]; // new Array(1);\n\n                var td = [[]]; // new Array(1);\n\n                InfTree.inflate_trees_fixed(bl, bd, tl, td);\n                codes.init(bl[0], bd[0], tl[0], 0, td[0], 0); // }\n                // {\n\n                b >>>= 3;\n                k -= 3; // }\n\n                mode = CODES;\n                break;\n\n              case 2:\n                // dynamic\n                // {\n                b >>>= 3;\n                k -= 3; // }\n\n                mode = TABLE;\n                break;\n\n              case 3:\n                // illegal\n                // {\n                b >>>= 3;\n                k -= 3; // }\n\n                mode = BADBLOCKS;\n                z.msg = \"invalid block type\";\n                r = Z_DATA_ERROR;\n                that.bitb = b;\n                that.bitk = k;\n                z.avail_in = n;\n                z.total_in += p - z.next_in_index;\n                z.next_in_index = p;\n                that.write = q;\n                return that.inflate_flush(z, r);\n            }\n\n            break;\n\n          case LENS:\n            while (k < 32) {\n              if (n !== 0) {\n                r = Z_OK;\n              } else {\n                that.bitb = b;\n                that.bitk = k;\n                z.avail_in = n;\n                z.total_in += p - z.next_in_index;\n                z.next_in_index = p;\n                that.write = q;\n                return that.inflate_flush(z, r);\n              }\n\n              n--;\n              b |= (z.read_byte(p++) & 0xff) << k;\n              k += 8;\n            }\n\n            if ((~b >>> 16 & 0xffff) != (b & 0xffff)) {\n              mode = BADBLOCKS;\n              z.msg = \"invalid stored block lengths\";\n              r = Z_DATA_ERROR;\n              that.bitb = b;\n              that.bitk = k;\n              z.avail_in = n;\n              z.total_in += p - z.next_in_index;\n              z.next_in_index = p;\n              that.write = q;\n              return that.inflate_flush(z, r);\n            }\n\n            left = b & 0xffff;\n            b = k = 0; // dump bits\n\n            mode = left !== 0 ? STORED : last !== 0 ? DRY : TYPE;\n            break;\n\n          case STORED:\n            if (n === 0) {\n              that.bitb = b;\n              that.bitk = k;\n              z.avail_in = n;\n              z.total_in += p - z.next_in_index;\n              z.next_in_index = p;\n              that.write = q;\n              return that.inflate_flush(z, r);\n            }\n\n            if (m === 0) {\n              if (q == that.end && that.read !== 0) {\n                q = 0;\n                m =\n                /* (int) */\n                q < that.read ? that.read - q - 1 : that.end - q;\n              }\n\n              if (m === 0) {\n                that.write = q;\n                r = that.inflate_flush(z, r);\n                q = that.write;\n                m =\n                /* (int) */\n                q < that.read ? that.read - q - 1 : that.end - q;\n\n                if (q == that.end && that.read !== 0) {\n                  q = 0;\n                  m =\n                  /* (int) */\n                  q < that.read ? that.read - q - 1 : that.end - q;\n                }\n\n                if (m === 0) {\n                  that.bitb = b;\n                  that.bitk = k;\n                  z.avail_in = n;\n                  z.total_in += p - z.next_in_index;\n                  z.next_in_index = p;\n                  that.write = q;\n                  return that.inflate_flush(z, r);\n                }\n              }\n            }\n\n            r = Z_OK;\n            t = left;\n            if (t > n) t = n;\n            if (t > m) t = m;\n            that.window.set(z.read_buf(p, t), q);\n            p += t;\n            n -= t;\n            q += t;\n            m -= t;\n            if ((left -= t) !== 0) break;\n            mode = last !== 0 ? DRY : TYPE;\n            break;\n\n          case TABLE:\n            while (k < 14) {\n              if (n !== 0) {\n                r = Z_OK;\n              } else {\n                that.bitb = b;\n                that.bitk = k;\n                z.avail_in = n;\n                z.total_in += p - z.next_in_index;\n                z.next_in_index = p;\n                that.write = q;\n                return that.inflate_flush(z, r);\n              }\n\n              n--;\n              b |= (z.read_byte(p++) & 0xff) << k;\n              k += 8;\n            }\n\n            table = t = b & 0x3fff;\n\n            if ((t & 0x1f) > 29 || (t >> 5 & 0x1f) > 29) {\n              mode = BADBLOCKS;\n              z.msg = \"too many length or distance symbols\";\n              r = Z_DATA_ERROR;\n              that.bitb = b;\n              that.bitk = k;\n              z.avail_in = n;\n              z.total_in += p - z.next_in_index;\n              z.next_in_index = p;\n              that.write = q;\n              return that.inflate_flush(z, r);\n            }\n\n            t = 258 + (t & 0x1f) + (t >> 5 & 0x1f);\n\n            if (!blens || blens.length < t) {\n              blens = []; // new Array(t);\n            } else {\n              for (i = 0; i < t; i++) {\n                blens[i] = 0;\n              }\n            } // {\n\n\n            b >>>= 14;\n            k -= 14; // }\n\n            index = 0;\n            mode = BTREE;\n\n          /* falls through */\n\n          case BTREE:\n            while (index < 4 + (table >>> 10)) {\n              while (k < 3) {\n                if (n !== 0) {\n                  r = Z_OK;\n                } else {\n                  that.bitb = b;\n                  that.bitk = k;\n                  z.avail_in = n;\n                  z.total_in += p - z.next_in_index;\n                  z.next_in_index = p;\n                  that.write = q;\n                  return that.inflate_flush(z, r);\n                }\n\n                n--;\n                b |= (z.read_byte(p++) & 0xff) << k;\n                k += 8;\n              }\n\n              blens[border[index++]] = b & 7; // {\n\n              b >>>= 3;\n              k -= 3; // }\n            }\n\n            while (index < 19) {\n              blens[border[index++]] = 0;\n            }\n\n            bb[0] = 7;\n            t = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);\n\n            if (t != Z_OK) {\n              r = t;\n\n              if (r == Z_DATA_ERROR) {\n                blens = null;\n                mode = BADBLOCKS;\n              }\n\n              that.bitb = b;\n              that.bitk = k;\n              z.avail_in = n;\n              z.total_in += p - z.next_in_index;\n              z.next_in_index = p;\n              that.write = q;\n              return that.inflate_flush(z, r);\n            }\n\n            index = 0;\n            mode = DTREE;\n\n          /* falls through */\n\n          case DTREE:\n            while (true) {\n              t = table;\n\n              if (index >= 258 + (t & 0x1f) + (t >> 5 & 0x1f)) {\n                break;\n              }\n\n              var j, c;\n              t = bb[0];\n\n              while (k < t) {\n                if (n !== 0) {\n                  r = Z_OK;\n                } else {\n                  that.bitb = b;\n                  that.bitk = k;\n                  z.avail_in = n;\n                  z.total_in += p - z.next_in_index;\n                  z.next_in_index = p;\n                  that.write = q;\n                  return that.inflate_flush(z, r);\n                }\n\n                n--;\n                b |= (z.read_byte(p++) & 0xff) << k;\n                k += 8;\n              } // if (tb[0] == -1) {\n              // System.err.println(\"null...\");\n              // }\n\n\n              t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];\n              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];\n\n              if (c < 16) {\n                b >>>= t;\n                k -= t;\n                blens[index++] = c;\n              } else {\n                // c == 16..18\n                i = c == 18 ? 7 : c - 14;\n                j = c == 18 ? 11 : 3;\n\n                while (k < t + i) {\n                  if (n !== 0) {\n                    r = Z_OK;\n                  } else {\n                    that.bitb = b;\n                    that.bitk = k;\n                    z.avail_in = n;\n                    z.total_in += p - z.next_in_index;\n                    z.next_in_index = p;\n                    that.write = q;\n                    return that.inflate_flush(z, r);\n                  }\n\n                  n--;\n                  b |= (z.read_byte(p++) & 0xff) << k;\n                  k += 8;\n                }\n\n                b >>>= t;\n                k -= t;\n                j += b & inflate_mask[i];\n                b >>>= i;\n                k -= i;\n                i = index;\n                t = table;\n\n                if (i + j > 258 + (t & 0x1f) + (t >> 5 & 0x1f) || c == 16 && i < 1) {\n                  blens = null;\n                  mode = BADBLOCKS;\n                  z.msg = \"invalid bit length repeat\";\n                  r = Z_DATA_ERROR;\n                  that.bitb = b;\n                  that.bitk = k;\n                  z.avail_in = n;\n                  z.total_in += p - z.next_in_index;\n                  z.next_in_index = p;\n                  that.write = q;\n                  return that.inflate_flush(z, r);\n                }\n\n                c = c == 16 ? blens[i - 1] : 0;\n\n                do {\n                  blens[i++] = c;\n                } while (--j !== 0);\n\n                index = i;\n              }\n            }\n\n            tb[0] = -1; // {\n\n            var bl_ = []; // new Array(1);\n\n            var bd_ = []; // new Array(1);\n\n            var tl_ = []; // new Array(1);\n\n            var td_ = []; // new Array(1);\n\n            bl_[0] = 9; // must be <= 9 for lookahead assumptions\n\n            bd_[0] = 6; // must be <= 9 for lookahead assumptions\n\n            t = table;\n            t = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + (t >> 5 & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);\n\n            if (t != Z_OK) {\n              if (t == Z_DATA_ERROR) {\n                blens = null;\n                mode = BADBLOCKS;\n              }\n\n              r = t;\n              that.bitb = b;\n              that.bitk = k;\n              z.avail_in = n;\n              z.total_in += p - z.next_in_index;\n              z.next_in_index = p;\n              that.write = q;\n              return that.inflate_flush(z, r);\n            }\n\n            codes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]); // }\n\n            mode = CODES;\n\n          /* falls through */\n\n          case CODES:\n            that.bitb = b;\n            that.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;\n            z.next_in_index = p;\n            that.write = q;\n\n            if ((r = codes.proc(that, z, r)) != Z_STREAM_END) {\n              return that.inflate_flush(z, r);\n            }\n\n            r = Z_OK;\n            codes.free(z);\n            p = z.next_in_index;\n            n = z.avail_in;\n            b = that.bitb;\n            k = that.bitk;\n            q = that.write;\n            m =\n            /* (int) */\n            q < that.read ? that.read - q - 1 : that.end - q;\n\n            if (last === 0) {\n              mode = TYPE;\n              break;\n            }\n\n            mode = DRY;\n\n          /* falls through */\n\n          case DRY:\n            that.write = q;\n            r = that.inflate_flush(z, r);\n            q = that.write;\n            m =\n            /* (int) */\n            q < that.read ? that.read - q - 1 : that.end - q;\n\n            if (that.read != that.write) {\n              that.bitb = b;\n              that.bitk = k;\n              z.avail_in = n;\n              z.total_in += p - z.next_in_index;\n              z.next_in_index = p;\n              that.write = q;\n              return that.inflate_flush(z, r);\n            }\n\n            mode = DONELOCKS;\n\n          /* falls through */\n\n          case DONELOCKS:\n            r = Z_STREAM_END;\n            that.bitb = b;\n            that.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;\n            z.next_in_index = p;\n            that.write = q;\n            return that.inflate_flush(z, r);\n\n          case BADBLOCKS:\n            r = Z_DATA_ERROR;\n            that.bitb = b;\n            that.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;\n            z.next_in_index = p;\n            that.write = q;\n            return that.inflate_flush(z, r);\n\n          default:\n            r = Z_STREAM_ERROR;\n            that.bitb = b;\n            that.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;\n            z.next_in_index = p;\n            that.write = q;\n            return that.inflate_flush(z, r);\n        }\n      }\n    };\n\n    that.free = function (z) {\n      that.reset(z, null);\n      that.window = null;\n      hufts = null; // ZFREE(z, s);\n    };\n\n    that.set_dictionary = function (d, start, n) {\n      that.window.set(d.subarray(start, start + n), 0);\n      that.read = that.write = n;\n    }; // Returns true if inflate is currently at the end of a block generated\n    // by Z_SYNC_FLUSH or Z_FULL_FLUSH.\n\n\n    that.sync_point = function () {\n      return mode == LENS ? 1 : 0;\n    };\n  } // Inflate\n  // preset dictionary flag in zlib header\n\n\n  var PRESET_DICT = 0x20;\n  var Z_DEFLATED = 8;\n  var METHOD = 0; // waiting for method byte\n\n  var FLAG = 1; // waiting for flag byte\n\n  var DICT4 = 2; // four dictionary check bytes to go\n\n  var DICT3 = 3; // three dictionary check bytes to go\n\n  var DICT2 = 4; // two dictionary check bytes to go\n\n  var DICT1 = 5; // one dictionary check byte to go\n\n  var DICT0 = 6; // waiting for inflateSetDictionary\n\n  var BLOCKS = 7; // decompressing blocks\n\n  var DONE = 12; // finished check, done\n\n  var BAD = 13; // got an error--stay here\n\n  var mark = [0, 0, 0xff, 0xff];\n\n  function Inflate() {\n    var that = this;\n    that.mode = 0; // current inflate mode\n    // mode dependent information\n\n    that.method = 0; // if FLAGS, method byte\n    // if CHECK, check values to compare\n\n    that.was = [0]; // new Array(1); // computed check value\n\n    that.need = 0; // stream check value\n    // if BAD, inflateSync's marker bytes count\n\n    that.marker = 0; // mode independent information\n\n    that.wbits = 0; // log2(window size) (8..15, defaults to 15)\n    // this.blocks; // current inflate_blocks state\n\n    function inflateReset(z) {\n      if (!z || !z.istate) return Z_STREAM_ERROR;\n      z.total_in = z.total_out = 0;\n      z.msg = null;\n      z.istate.mode = BLOCKS;\n      z.istate.blocks.reset(z, null);\n      return Z_OK;\n    }\n\n    that.inflateEnd = function (z) {\n      if (that.blocks) that.blocks.free(z);\n      that.blocks = null; // ZFREE(z, z->state);\n\n      return Z_OK;\n    };\n\n    that.inflateInit = function (z, w) {\n      z.msg = null;\n      that.blocks = null; // set window size\n\n      if (w < 8 || w > 15) {\n        that.inflateEnd(z);\n        return Z_STREAM_ERROR;\n      }\n\n      that.wbits = w;\n      z.istate.blocks = new InfBlocks(z, 1 << w); // reset state\n\n      inflateReset(z);\n      return Z_OK;\n    };\n\n    that.inflate = function (z, f) {\n      var r;\n      var b;\n      if (!z || !z.istate || !z.next_in) return Z_STREAM_ERROR;\n      f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n      r = Z_BUF_ERROR;\n\n      while (true) {\n        // System.out.println(\"mode: \"+z.istate.mode);\n        switch (z.istate.mode) {\n          case METHOD:\n            if (z.avail_in === 0) return r;\n            r = f;\n            z.avail_in--;\n            z.total_in++;\n\n            if (((z.istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED) {\n              z.istate.mode = BAD;\n              z.msg = \"unknown compression method\";\n              z.istate.marker = 5; // can't try inflateSync\n\n              break;\n            }\n\n            if ((z.istate.method >> 4) + 8 > z.istate.wbits) {\n              z.istate.mode = BAD;\n              z.msg = \"invalid window size\";\n              z.istate.marker = 5; // can't try inflateSync\n\n              break;\n            }\n\n            z.istate.mode = FLAG;\n\n          /* falls through */\n\n          case FLAG:\n            if (z.avail_in === 0) return r;\n            r = f;\n            z.avail_in--;\n            z.total_in++;\n            b = z.read_byte(z.next_in_index++) & 0xff;\n\n            if (((z.istate.method << 8) + b) % 31 !== 0) {\n              z.istate.mode = BAD;\n              z.msg = \"incorrect header check\";\n              z.istate.marker = 5; // can't try inflateSync\n\n              break;\n            }\n\n            if ((b & PRESET_DICT) === 0) {\n              z.istate.mode = BLOCKS;\n              break;\n            }\n\n            z.istate.mode = DICT4;\n\n          /* falls through */\n\n          case DICT4:\n            if (z.avail_in === 0) return r;\n            r = f;\n            z.avail_in--;\n            z.total_in++;\n            z.istate.need = (z.read_byte(z.next_in_index++) & 0xff) << 24 & 0xff000000;\n            z.istate.mode = DICT3;\n\n          /* falls through */\n\n          case DICT3:\n            if (z.avail_in === 0) return r;\n            r = f;\n            z.avail_in--;\n            z.total_in++;\n            z.istate.need += (z.read_byte(z.next_in_index++) & 0xff) << 16 & 0xff0000;\n            z.istate.mode = DICT2;\n\n          /* falls through */\n\n          case DICT2:\n            if (z.avail_in === 0) return r;\n            r = f;\n            z.avail_in--;\n            z.total_in++;\n            z.istate.need += (z.read_byte(z.next_in_index++) & 0xff) << 8 & 0xff00;\n            z.istate.mode = DICT1;\n\n          /* falls through */\n\n          case DICT1:\n            if (z.avail_in === 0) return r;\n            r = f;\n            z.avail_in--;\n            z.total_in++;\n            z.istate.need += z.read_byte(z.next_in_index++) & 0xff;\n            z.istate.mode = DICT0;\n            return Z_NEED_DICT;\n\n          case DICT0:\n            z.istate.mode = BAD;\n            z.msg = \"need dictionary\";\n            z.istate.marker = 0; // can try inflateSync\n\n            return Z_STREAM_ERROR;\n\n          case BLOCKS:\n            r = z.istate.blocks.proc(z, r);\n\n            if (r == Z_DATA_ERROR) {\n              z.istate.mode = BAD;\n              z.istate.marker = 0; // can try inflateSync\n\n              break;\n            }\n\n            if (r == Z_OK) {\n              r = f;\n            }\n\n            if (r != Z_STREAM_END) {\n              return r;\n            }\n\n            r = f;\n            z.istate.blocks.reset(z, z.istate.was);\n            z.istate.mode = DONE;\n\n          /* falls through */\n\n          case DONE:\n            return Z_STREAM_END;\n\n          case BAD:\n            return Z_DATA_ERROR;\n\n          default:\n            return Z_STREAM_ERROR;\n        }\n      }\n    };\n\n    that.inflateSetDictionary = function (z, dictionary, dictLength) {\n      var index = 0;\n      var length = dictLength;\n      if (!z || !z.istate || z.istate.mode != DICT0) return Z_STREAM_ERROR;\n\n      if (length >= 1 << z.istate.wbits) {\n        length = (1 << z.istate.wbits) - 1;\n        index = dictLength - length;\n      }\n\n      z.istate.blocks.set_dictionary(dictionary, index, length);\n      z.istate.mode = BLOCKS;\n      return Z_OK;\n    };\n\n    that.inflateSync = function (z) {\n      var n; // number of bytes to look at\n\n      var p; // pointer to bytes\n\n      var m; // number of marker bytes found in a row\n\n      var r, w; // temporaries to save total_in and total_out\n      // set up\n\n      if (!z || !z.istate) return Z_STREAM_ERROR;\n\n      if (z.istate.mode != BAD) {\n        z.istate.mode = BAD;\n        z.istate.marker = 0;\n      }\n\n      if ((n = z.avail_in) === 0) return Z_BUF_ERROR;\n      p = z.next_in_index;\n      m = z.istate.marker; // search\n\n      while (n !== 0 && m < 4) {\n        if (z.read_byte(p) == mark[m]) {\n          m++;\n        } else if (z.read_byte(p) !== 0) {\n          m = 0;\n        } else {\n          m = 4 - m;\n        }\n\n        p++;\n        n--;\n      } // restore\n\n\n      z.total_in += p - z.next_in_index;\n      z.next_in_index = p;\n      z.avail_in = n;\n      z.istate.marker = m; // return no joy or set up to restart on a new block\n\n      if (m != 4) {\n        return Z_DATA_ERROR;\n      }\n\n      r = z.total_in;\n      w = z.total_out;\n      inflateReset(z);\n      z.total_in = r;\n      z.total_out = w;\n      z.istate.mode = BLOCKS;\n      return Z_OK;\n    }; // Returns true if inflate is currently at the end of a block generated\n    // by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n    // implementation to provide an additional safety check. PPP uses\n    // Z_SYNC_FLUSH\n    // but removes the length bytes of the resulting empty stored block. When\n    // decompressing, PPP checks that at the end of input packet, inflate is\n    // waiting for these length bytes.\n\n\n    that.inflateSyncPoint = function (z) {\n      if (!z || !z.istate || !z.istate.blocks) return Z_STREAM_ERROR;\n      return z.istate.blocks.sync_point();\n    };\n  } // ZStream\n\n\n  function ZStream() {}\n\n  ZStream.prototype = {\n    inflateInit: function (bits) {\n      var that = this;\n      that.istate = new Inflate();\n      if (!bits) bits = MAX_BITS;\n      return that.istate.inflateInit(that, bits);\n    },\n    inflate: function (f) {\n      var that = this;\n      if (!that.istate) return Z_STREAM_ERROR;\n      return that.istate.inflate(that, f);\n    },\n    inflateEnd: function () {\n      var that = this;\n      if (!that.istate) return Z_STREAM_ERROR;\n      var ret = that.istate.inflateEnd(that);\n      that.istate = null;\n      return ret;\n    },\n    inflateSync: function () {\n      var that = this;\n      if (!that.istate) return Z_STREAM_ERROR;\n      return that.istate.inflateSync(that);\n    },\n    inflateSetDictionary: function (dictionary, dictLength) {\n      var that = this;\n      if (!that.istate) return Z_STREAM_ERROR;\n      return that.istate.inflateSetDictionary(that, dictionary, dictLength);\n    },\n    read_byte: function (start) {\n      var that = this;\n      return that.next_in.subarray(start, start + 1)[0];\n    },\n    read_buf: function (start, size) {\n      var that = this;\n      return that.next_in.subarray(start, start + size);\n    }\n  }; // Inflater\n\n  function Inflater() {\n    var that = this;\n    var z = new ZStream();\n    var bufsize = 512;\n    var flush = Z_NO_FLUSH;\n    var buf = new Uint8Array(bufsize);\n    var nomoreinput = false;\n    z.inflateInit();\n    z.next_out = buf;\n\n    that.append = function (data, onprogress) {\n      var err,\n          buffers = [],\n          lastIndex = 0,\n          bufferIndex = 0,\n          bufferSize = 0,\n          array;\n      if (data.length === 0) return;\n      z.next_in_index = 0;\n      z.next_in = data;\n      z.avail_in = data.length;\n\n      do {\n        z.next_out_index = 0;\n        z.avail_out = bufsize;\n\n        if (z.avail_in === 0 && !nomoreinput) {\n          // if buffer is empty and more input is available, refill it\n          z.next_in_index = 0;\n          nomoreinput = true;\n        }\n\n        err = z.inflate(flush);\n\n        if (nomoreinput && err === Z_BUF_ERROR) {\n          if (z.avail_in !== 0) throw new Error(\"inflating: bad input\");\n        } else if (err !== Z_OK && err !== Z_STREAM_END) throw new Error(\"inflating: \" + z.msg);\n\n        if ((nomoreinput || err === Z_STREAM_END) && z.avail_in === data.length) throw new Error(\"inflating: bad input\");\n        if (z.next_out_index) if (z.next_out_index === bufsize) buffers.push(new Uint8Array(buf));else buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\n        bufferSize += z.next_out_index;\n\n        if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {\n          onprogress(z.next_in_index);\n          lastIndex = z.next_in_index;\n        }\n      } while (z.avail_in > 0 || z.avail_out === 0);\n\n      array = new Uint8Array(bufferSize);\n      buffers.forEach(function (chunk) {\n        array.set(chunk, bufferIndex);\n        bufferIndex += chunk.length;\n      });\n      return array;\n    };\n\n    that.flush = function () {\n      z.inflateEnd();\n    };\n  } // 'zip' may not be defined in z-worker and some tests\n\n\n  var env = global.zip || global;\n  env.Inflater = env._jzlib_Inflater = Inflater;\n})(this);\n\n//# sourceURL=webpack:///./lib/inflate.js?");

/***/ }),

/***/ "./lib/zip-ext.js":
/*!************************!*\
  !*** ./lib/zip-ext.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright\n notice, this list of conditions and the following disclaimer in\n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n(function () {\n  \"use strict\";\n\n  var ERR_HTTP_RANGE = \"HTTP Range not supported.\";\n  var Reader = zip.Reader;\n  var Writer = zip.Writer;\n  var ZipDirectoryEntry;\n  var appendABViewSupported;\n\n  try {\n    appendABViewSupported = new Blob([new DataView(new ArrayBuffer(0))]).size === 0;\n  } catch (e) {}\n\n  function isHttpFamily(url) {\n    var a = document.createElement(\"a\");\n    a.href = url;\n    return a.protocol === \"http:\" || a.protocol === \"https:\";\n  }\n\n  function HttpReader(url) {\n    var that = this;\n\n    function getData(callback, onerror) {\n      var request;\n\n      if (!that.data) {\n        request = new XMLHttpRequest();\n        request.addEventListener(\"load\", function () {\n          if (!that.size) that.size = Number(request.getResponseHeader(\"Content-Length\")) || Number(request.response.byteLength);\n          that.data = new Uint8Array(request.response);\n          callback();\n        }, false);\n        request.addEventListener(\"error\", onerror, false);\n        request.open(\"GET\", url);\n        request.responseType = \"arraybuffer\";\n        request.send();\n      } else callback();\n    }\n\n    function init(callback, onerror) {\n      if (!isHttpFamily(url)) {\n        // For schemas other than http(s), HTTP HEAD may be unavailable,\n        // so use HTTP GET instead.\n        getData(callback, onerror);\n        return;\n      }\n\n      var request = new XMLHttpRequest();\n      request.addEventListener(\"load\", function () {\n        that.size = Number(request.getResponseHeader(\"Content-Length\")); // If response header doesn't return size then prefetch the content.\n\n        if (!that.size) {\n          getData(callback, onerror);\n        } else {\n          callback();\n        }\n      }, false);\n      request.addEventListener(\"error\", onerror, false);\n      request.open(\"HEAD\", url);\n      request.send();\n    }\n\n    function readUint8Array(index, length, callback, onerror) {\n      getData(function () {\n        callback(new Uint8Array(that.data.subarray(index, index + length)));\n      }, onerror);\n    }\n\n    that.size = 0;\n    that.init = init;\n    that.readUint8Array = readUint8Array;\n  }\n\n  HttpReader.prototype = new Reader();\n  HttpReader.prototype.constructor = HttpReader;\n\n  function HttpRangeReader(url) {\n    var that = this;\n\n    function init(callback, onerror) {\n      var request = new XMLHttpRequest();\n      request.addEventListener(\"load\", function () {\n        that.size = Number(request.getResponseHeader(\"Content-Length\"));\n        if (request.getResponseHeader(\"Accept-Ranges\") == \"bytes\") callback();else onerror(ERR_HTTP_RANGE);\n      }, false);\n      request.addEventListener(\"error\", onerror, false);\n      request.open(\"HEAD\", url);\n      request.send();\n    }\n\n    function readArrayBuffer(index, length, callback, onerror) {\n      var request = new XMLHttpRequest();\n      request.open(\"GET\", url);\n      request.responseType = \"arraybuffer\";\n      request.setRequestHeader(\"Range\", \"bytes=\" + index + \"-\" + (index + length - 1));\n      request.addEventListener(\"load\", function () {\n        callback(request.response);\n      }, false);\n      request.addEventListener(\"error\", onerror, false);\n      request.send();\n    }\n\n    function readUint8Array(index, length, callback, onerror) {\n      readArrayBuffer(index, length, function (arraybuffer) {\n        callback(new Uint8Array(arraybuffer));\n      }, onerror);\n    }\n\n    that.size = 0;\n    that.init = init;\n    that.readUint8Array = readUint8Array;\n  }\n\n  HttpRangeReader.prototype = new Reader();\n  HttpRangeReader.prototype.constructor = HttpRangeReader;\n\n  function ArrayBufferReader(arrayBuffer) {\n    var that = this;\n\n    function init(callback, onerror) {\n      that.size = arrayBuffer.byteLength;\n      callback();\n    }\n\n    function readUint8Array(index, length, callback, onerror) {\n      callback(new Uint8Array(arrayBuffer.slice(index, index + length)));\n    }\n\n    that.size = 0;\n    that.init = init;\n    that.readUint8Array = readUint8Array;\n  }\n\n  ArrayBufferReader.prototype = new Reader();\n  ArrayBufferReader.prototype.constructor = ArrayBufferReader;\n\n  function ArrayBufferWriter() {\n    var array,\n        that = this;\n\n    function init(callback, onerror) {\n      array = new Uint8Array();\n      callback();\n    }\n\n    function writeUint8Array(arr, callback, onerror) {\n      var tmpArray = new Uint8Array(array.length + arr.length);\n      tmpArray.set(array);\n      tmpArray.set(arr, array.length);\n      array = tmpArray;\n      callback();\n    }\n\n    function getData(callback) {\n      callback(array.buffer);\n    }\n\n    that.init = init;\n    that.writeUint8Array = writeUint8Array;\n    that.getData = getData;\n  }\n\n  ArrayBufferWriter.prototype = new Writer();\n  ArrayBufferWriter.prototype.constructor = ArrayBufferWriter;\n\n  function FileWriter(fileEntry, contentType) {\n    var writer,\n        that = this;\n\n    function init(callback, onerror) {\n      fileEntry.createWriter(function (fileWriter) {\n        writer = fileWriter;\n        callback();\n      }, onerror);\n    }\n\n    function writeUint8Array(array, callback, onerror) {\n      var blob = new Blob([appendABViewSupported ? array : array.buffer], {\n        type: contentType\n      });\n\n      writer.onwrite = function () {\n        writer.onwrite = null;\n        callback();\n      };\n\n      writer.onerror = onerror;\n      writer.write(blob);\n    }\n\n    function getData(callback) {\n      fileEntry.file(callback);\n    }\n\n    that.init = init;\n    that.writeUint8Array = writeUint8Array;\n    that.getData = getData;\n  }\n\n  FileWriter.prototype = new Writer();\n  FileWriter.prototype.constructor = FileWriter;\n  zip.FileWriter = FileWriter;\n  zip.HttpReader = HttpReader;\n  zip.HttpRangeReader = HttpRangeReader;\n  zip.ArrayBufferReader = ArrayBufferReader;\n  zip.ArrayBufferWriter = ArrayBufferWriter;\n\n  if (zip.fs) {\n    ZipDirectoryEntry = zip.fs.ZipDirectoryEntry;\n\n    ZipDirectoryEntry.prototype.addHttpContent = function (name, URL, useRangeHeader) {\n      function addChild(parent, name, params, directory) {\n        if (parent.directory) return directory ? new ZipDirectoryEntry(parent.fs, name, params, parent) : new zip.fs.ZipFileEntry(parent.fs, name, params, parent);else throw \"Parent entry is not a directory.\";\n      }\n\n      return addChild(this, name, {\n        data: URL,\n        Reader: useRangeHeader ? HttpRangeReader : HttpReader\n      });\n    };\n\n    ZipDirectoryEntry.prototype.importHttpContent = function (URL, useRangeHeader, onend, onerror) {\n      this.importZip(useRangeHeader ? new HttpRangeReader(URL) : new HttpReader(URL), onend, onerror);\n    };\n\n    zip.fs.FS.prototype.importHttpContent = function (URL, useRangeHeader, onend, onerror) {\n      this.entries = [];\n      this.root = new ZipDirectoryEntry(this);\n      this.root.importHttpContent(URL, useRangeHeader, onend, onerror);\n    };\n  }\n})();\n\n//# sourceURL=webpack:///./lib/zip-ext.js?");

/***/ }),

/***/ "./lib/zip.js":
/*!********************!*\
  !*** ./lib/zip.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright\n notice, this list of conditions and the following disclaimer in\n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n(function (obj) {\n  \"use strict\";\n\n  var ERR_BAD_FORMAT = \"File format is not recognized.\";\n  var ERR_CRC = \"CRC failed.\";\n  var ERR_ENCRYPTED = \"File contains encrypted entry.\";\n  var ERR_ZIP64 = \"File is using Zip64 (4gb+ file size).\";\n  var ERR_READ = \"Error while reading zip file.\";\n  var ERR_WRITE = \"Error while writing zip file.\";\n  var ERR_WRITE_DATA = \"Error while writing file data.\";\n  var ERR_READ_DATA = \"Error while reading file data.\";\n  var ERR_DUPLICATED_NAME = \"File already exists.\";\n  var CHUNK_SIZE = 512 * 1024;\n  var TEXT_PLAIN = \"text/plain\";\n  var appendABViewSupported;\n\n  try {\n    appendABViewSupported = new Blob([new DataView(new ArrayBuffer(0))]).size === 0;\n  } catch (e) {}\n\n  function Crc32() {\n    this.crc = -1;\n  }\n\n  Crc32.prototype.append = function append(data) {\n    var crc = this.crc | 0,\n        table = this.table;\n\n    for (var offset = 0, len = data.length | 0; offset < len; offset++) crc = crc >>> 8 ^ table[(crc ^ data[offset]) & 0xFF];\n\n    this.crc = crc;\n  };\n\n  Crc32.prototype.get = function get() {\n    return ~this.crc;\n  };\n\n  Crc32.prototype.table = function () {\n    var i,\n        j,\n        t,\n        table = []; // Uint32Array is actually slower than []\n\n    for (i = 0; i < 256; i++) {\n      t = i;\n\n      for (j = 0; j < 8; j++) if (t & 1) t = t >>> 1 ^ 0xEDB88320;else t = t >>> 1;\n\n      table[i] = t;\n    }\n\n    return table;\n  }(); // \"no-op\" codec\n\n\n  function NOOP() {}\n\n  NOOP.prototype.append = function append(bytes, onprogress) {\n    return bytes;\n  };\n\n  NOOP.prototype.flush = function flush() {};\n\n  function blobSlice(blob, index, length) {\n    if (index < 0 || length < 0 || index + length > blob.size) throw new RangeError('offset:' + index + ', length:' + length + ', size:' + blob.size);\n    if (blob.slice) return blob.slice(index, index + length);else if (blob.webkitSlice) return blob.webkitSlice(index, index + length);else if (blob.mozSlice) return blob.mozSlice(index, index + length);else if (blob.msSlice) return blob.msSlice(index, index + length);\n  }\n\n  function getDataHelper(byteLength, bytes) {\n    var dataBuffer, dataArray;\n    dataBuffer = new ArrayBuffer(byteLength);\n    dataArray = new Uint8Array(dataBuffer);\n    if (bytes) dataArray.set(bytes, 0);\n    return {\n      buffer: dataBuffer,\n      array: dataArray,\n      view: new DataView(dataBuffer)\n    };\n  } // Readers\n\n\n  function Reader() {}\n\n  function TextReader(text) {\n    var that = this,\n        blobReader;\n\n    function init(callback, onerror) {\n      var blob = new Blob([text], {\n        type: TEXT_PLAIN\n      });\n      blobReader = new BlobReader(blob);\n      blobReader.init(function () {\n        that.size = blobReader.size;\n        callback();\n      }, onerror);\n    }\n\n    function readUint8Array(index, length, callback, onerror) {\n      blobReader.readUint8Array(index, length, callback, onerror);\n    }\n\n    that.size = 0;\n    that.init = init;\n    that.readUint8Array = readUint8Array;\n  }\n\n  TextReader.prototype = new Reader();\n  TextReader.prototype.constructor = TextReader;\n\n  function Data64URIReader(dataURI) {\n    var that = this,\n        dataStart;\n\n    function init(callback) {\n      var dataEnd = dataURI.length;\n\n      while (dataURI.charAt(dataEnd - 1) == \"=\") dataEnd--;\n\n      dataStart = dataURI.indexOf(\",\") + 1;\n      that.size = Math.floor((dataEnd - dataStart) * 0.75);\n      callback();\n    }\n\n    function readUint8Array(index, length, callback) {\n      var i,\n          data = getDataHelper(length);\n      var start = Math.floor(index / 3) * 4;\n      var end = Math.ceil((index + length) / 3) * 4;\n      var bytes = obj.atob(dataURI.substring(start + dataStart, end + dataStart));\n      var delta = index - Math.floor(start / 4) * 3;\n\n      for (i = delta; i < delta + length; i++) data.array[i - delta] = bytes.charCodeAt(i);\n\n      callback(data.array);\n    }\n\n    that.size = 0;\n    that.init = init;\n    that.readUint8Array = readUint8Array;\n  }\n\n  Data64URIReader.prototype = new Reader();\n  Data64URIReader.prototype.constructor = Data64URIReader;\n\n  function BlobReader(blob) {\n    var that = this;\n\n    function init(callback) {\n      that.size = blob.size;\n      callback();\n    }\n\n    function readUint8Array(index, length, callback, onerror) {\n      var reader = new FileReader();\n\n      reader.onload = function (e) {\n        callback(new Uint8Array(e.target.result));\n      };\n\n      reader.onerror = onerror;\n\n      try {\n        reader.readAsArrayBuffer(blobSlice(blob, index, length));\n      } catch (e) {\n        onerror(e);\n      }\n    }\n\n    that.size = 0;\n    that.init = init;\n    that.readUint8Array = readUint8Array;\n  }\n\n  BlobReader.prototype = new Reader();\n  BlobReader.prototype.constructor = BlobReader; // Writers\n\n  function Writer() {}\n\n  Writer.prototype.getData = function (callback) {\n    callback(this.data);\n  };\n\n  function TextWriter(encoding) {\n    var that = this,\n        blob;\n\n    function init(callback) {\n      blob = new Blob([], {\n        type: TEXT_PLAIN\n      });\n      callback();\n    }\n\n    function writeUint8Array(array, callback) {\n      blob = new Blob([blob, appendABViewSupported ? array : array.buffer], {\n        type: TEXT_PLAIN\n      });\n      callback();\n    }\n\n    function getData(callback, onerror) {\n      var reader = new FileReader();\n\n      reader.onload = function (e) {\n        callback(e.target.result);\n      };\n\n      reader.onerror = onerror;\n      reader.readAsText(blob, encoding);\n    }\n\n    that.init = init;\n    that.writeUint8Array = writeUint8Array;\n    that.getData = getData;\n  }\n\n  TextWriter.prototype = new Writer();\n  TextWriter.prototype.constructor = TextWriter;\n\n  function Data64URIWriter(contentType) {\n    var that = this,\n        data = \"\",\n        pending = \"\";\n\n    function init(callback) {\n      data += \"data:\" + (contentType || \"\") + \";base64,\";\n      callback();\n    }\n\n    function writeUint8Array(array, callback) {\n      var i,\n          delta = pending.length,\n          dataString = pending;\n      pending = \"\";\n\n      for (i = 0; i < Math.floor((delta + array.length) / 3) * 3 - delta; i++) dataString += String.fromCharCode(array[i]);\n\n      for (; i < array.length; i++) pending += String.fromCharCode(array[i]);\n\n      if (dataString.length > 2) data += obj.btoa(dataString);else pending = dataString;\n      callback();\n    }\n\n    function getData(callback) {\n      callback(data + obj.btoa(pending));\n    }\n\n    that.init = init;\n    that.writeUint8Array = writeUint8Array;\n    that.getData = getData;\n  }\n\n  Data64URIWriter.prototype = new Writer();\n  Data64URIWriter.prototype.constructor = Data64URIWriter;\n\n  function BlobWriter(contentType) {\n    var blob,\n        that = this;\n\n    function init(callback) {\n      blob = new Blob([], {\n        type: contentType\n      });\n      callback();\n    }\n\n    function writeUint8Array(array, callback) {\n      blob = new Blob([blob, appendABViewSupported ? array : array.buffer], {\n        type: contentType\n      });\n      callback();\n    }\n\n    function getData(callback) {\n      callback(blob);\n    }\n\n    that.init = init;\n    that.writeUint8Array = writeUint8Array;\n    that.getData = getData;\n  }\n\n  BlobWriter.prototype = new Writer();\n  BlobWriter.prototype.constructor = BlobWriter;\n  /** \n   * inflate/deflate core functions\n   * @param worker {Worker} web worker for the task.\n   * @param initialMessage {Object} initial message to be sent to the worker. should contain\n   *   sn(serial number for distinguishing multiple tasks sent to the worker), and codecClass.\n   *   This function may add more properties before sending.\n   */\n\n  function launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror) {\n    var chunkIndex = 0,\n        index,\n        outputSize,\n        sn = initialMessage.sn,\n        crc;\n\n    function onflush() {\n      worker.removeEventListener('message', onmessage, false);\n      onend(outputSize, crc);\n    }\n\n    function onmessage(event) {\n      var message = event.data,\n          data = message.data,\n          err = message.error;\n\n      if (err) {\n        err.toString = function () {\n          return 'Error: ' + this.message;\n        };\n\n        onreaderror(err);\n        return;\n      }\n\n      if (message.sn !== sn) return;\n      if (typeof message.codecTime === 'number') worker.codecTime += message.codecTime; // should be before onflush()\n\n      if (typeof message.crcTime === 'number') worker.crcTime += message.crcTime;\n\n      switch (message.type) {\n        case 'append':\n          if (data) {\n            outputSize += data.length;\n            writer.writeUint8Array(data, function () {\n              step();\n            }, onwriteerror);\n          } else step();\n\n          break;\n\n        case 'flush':\n          crc = message.crc;\n\n          if (data) {\n            outputSize += data.length;\n            writer.writeUint8Array(data, function () {\n              onflush();\n            }, onwriteerror);\n          } else onflush();\n\n          break;\n\n        case 'progress':\n          if (onprogress) onprogress(index + message.loaded, size);\n          break;\n\n        case 'importScripts': //no need to handle here\n\n        case 'newTask':\n        case 'echo':\n          break;\n\n        default:\n          console.warn('zip.js:launchWorkerProcess: unknown message: ', message);\n      }\n    }\n\n    function step() {\n      index = chunkIndex * CHUNK_SIZE; // use `<=` instead of `<`, because `size` may be 0.\n\n      if (index <= size) {\n        reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function (array) {\n          if (onprogress) onprogress(index, size);\n          var msg = index === 0 ? initialMessage : {\n            sn: sn\n          };\n          msg.type = 'append';\n          msg.data = array; // posting a message with transferables will fail on IE10\n\n          try {\n            worker.postMessage(msg, [array.buffer]);\n          } catch (ex) {\n            worker.postMessage(msg); // retry without transferables\n          }\n\n          chunkIndex++;\n        }, onreaderror);\n      } else {\n        worker.postMessage({\n          sn: sn,\n          type: 'flush'\n        });\n      }\n    }\n\n    outputSize = 0;\n    worker.addEventListener('message', onmessage, false);\n    step();\n  }\n\n  function launchProcess(process, reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror) {\n    var chunkIndex = 0,\n        index,\n        outputSize = 0,\n        crcInput = crcType === 'input',\n        crcOutput = crcType === 'output',\n        crc = new Crc32();\n\n    function step() {\n      var outputData;\n      index = chunkIndex * CHUNK_SIZE;\n      if (index < size) reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function (inputData) {\n        var outputData;\n\n        try {\n          outputData = process.append(inputData, function (loaded) {\n            if (onprogress) onprogress(index + loaded, size);\n          });\n        } catch (e) {\n          onreaderror(e);\n          return;\n        }\n\n        if (outputData) {\n          outputSize += outputData.length;\n          writer.writeUint8Array(outputData, function () {\n            chunkIndex++;\n            setTimeout(step, 1);\n          }, onwriteerror);\n          if (crcOutput) crc.append(outputData);\n        } else {\n          chunkIndex++;\n          setTimeout(step, 1);\n        }\n\n        if (crcInput) crc.append(inputData);\n        if (onprogress) onprogress(index, size);\n      }, onreaderror);else {\n        try {\n          outputData = process.flush();\n        } catch (e) {\n          onreaderror(e);\n          return;\n        }\n\n        if (outputData) {\n          if (crcOutput) crc.append(outputData);\n          outputSize += outputData.length;\n          writer.writeUint8Array(outputData, function () {\n            onend(outputSize, crc.get());\n          }, onwriteerror);\n        } else onend(outputSize, crc.get());\n      }\n    }\n\n    step();\n  }\n\n  function inflate(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {\n    var crcType = computeCrc32 ? 'output' : 'none';\n\n    if (obj.zip.useWebWorkers) {\n      var initialMessage = {\n        sn: sn,\n        codecClass: 'Inflater',\n        crcType: crcType\n      };\n      launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);\n    } else launchProcess(new obj.zip.Inflater(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);\n  }\n\n  function deflate(worker, sn, reader, writer, level, onend, onprogress, onreaderror, onwriteerror) {\n    var crcType = 'input';\n\n    if (obj.zip.useWebWorkers) {\n      var initialMessage = {\n        sn: sn,\n        options: {\n          level: level\n        },\n        codecClass: 'Deflater',\n        crcType: crcType\n      };\n      launchWorkerProcess(worker, initialMessage, reader, writer, 0, reader.size, onprogress, onend, onreaderror, onwriteerror);\n    } else launchProcess(new obj.zip.Deflater(), reader, writer, 0, reader.size, crcType, onprogress, onend, onreaderror, onwriteerror);\n  }\n\n  function copy(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {\n    var crcType = 'input';\n\n    if (obj.zip.useWebWorkers && computeCrc32) {\n      var initialMessage = {\n        sn: sn,\n        codecClass: 'NOOP',\n        crcType: crcType\n      };\n      launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);\n    } else launchProcess(new NOOP(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);\n  } // ZipReader\n\n\n  function decodeASCII(str) {\n    var i,\n        out = \"\",\n        charCode,\n        extendedASCII = ['\\u00C7', '\\u00FC', '\\u00E9', '\\u00E2', '\\u00E4', '\\u00E0', '\\u00E5', '\\u00E7', '\\u00EA', '\\u00EB', '\\u00E8', '\\u00EF', '\\u00EE', '\\u00EC', '\\u00C4', '\\u00C5', '\\u00C9', '\\u00E6', '\\u00C6', '\\u00F4', '\\u00F6', '\\u00F2', '\\u00FB', '\\u00F9', '\\u00FF', '\\u00D6', '\\u00DC', '\\u00F8', '\\u00A3', '\\u00D8', '\\u00D7', '\\u0192', '\\u00E1', '\\u00ED', '\\u00F3', '\\u00FA', '\\u00F1', '\\u00D1', '\\u00AA', '\\u00BA', '\\u00BF', '\\u00AE', '\\u00AC', '\\u00BD', '\\u00BC', '\\u00A1', '\\u00AB', '\\u00BB', '_', '_', '_', '\\u00A6', '\\u00A6', '\\u00C1', '\\u00C2', '\\u00C0', '\\u00A9', '\\u00A6', '\\u00A6', '+', '+', '\\u00A2', '\\u00A5', '+', '+', '-', '-', '+', '-', '+', '\\u00E3', '\\u00C3', '+', '+', '-', '-', '\\u00A6', '-', '+', '\\u00A4', '\\u00F0', '\\u00D0', '\\u00CA', '\\u00CB', '\\u00C8', 'i', '\\u00CD', '\\u00CE', '\\u00CF', '+', '+', '_', '_', '\\u00A6', '\\u00CC', '_', '\\u00D3', '\\u00DF', '\\u00D4', '\\u00D2', '\\u00F5', '\\u00D5', '\\u00B5', '\\u00FE', '\\u00DE', '\\u00DA', '\\u00DB', '\\u00D9', '\\u00FD', '\\u00DD', '\\u00AF', '\\u00B4', '\\u00AD', '\\u00B1', '_', '\\u00BE', '\\u00B6', '\\u00A7', '\\u00F7', '\\u00B8', '\\u00B0', '\\u00A8', '\\u00B7', '\\u00B9', '\\u00B3', '\\u00B2', '_', ' '];\n\n    for (i = 0; i < str.length; i++) {\n      charCode = str.charCodeAt(i) & 0xFF;\n      if (charCode > 127) out += extendedASCII[charCode - 128];else out += String.fromCharCode(charCode);\n    }\n\n    return out;\n  }\n\n  function decodeUTF8(string) {\n    return decodeURIComponent(escape(string));\n  }\n\n  function getString(bytes) {\n    var i,\n        str = \"\";\n\n    for (i = 0; i < bytes.length; i++) str += String.fromCharCode(bytes[i]);\n\n    return str;\n  }\n\n  function getDate(timeRaw) {\n    var date = (timeRaw & 0xffff0000) >> 16,\n        time = timeRaw & 0x0000ffff;\n\n    try {\n      return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5, (time & 0x001F) * 2, 0);\n    } catch (e) {}\n  }\n\n  function readCommonHeader(entry, data, index, centralDirectory, onerror) {\n    entry.version = data.view.getUint16(index, true);\n    entry.bitFlag = data.view.getUint16(index + 2, true);\n    entry.compressionMethod = data.view.getUint16(index + 4, true);\n    entry.lastModDateRaw = data.view.getUint32(index + 6, true);\n    entry.lastModDate = getDate(entry.lastModDateRaw);\n\n    if ((entry.bitFlag & 0x01) === 0x01) {\n      onerror(ERR_ENCRYPTED);\n      return;\n    }\n\n    if (centralDirectory || (entry.bitFlag & 0x0008) != 0x0008) {\n      entry.crc32 = data.view.getUint32(index + 10, true);\n      entry.compressedSize = data.view.getUint32(index + 14, true);\n      entry.uncompressedSize = data.view.getUint32(index + 18, true);\n    }\n\n    if (entry.compressedSize === 0xFFFFFFFF || entry.uncompressedSize === 0xFFFFFFFF) {\n      onerror(ERR_ZIP64);\n      return;\n    }\n\n    entry.filenameLength = data.view.getUint16(index + 22, true);\n    entry.extraFieldLength = data.view.getUint16(index + 24, true);\n  }\n\n  function createZipReader(reader, callback, onerror) {\n    var inflateSN = 0;\n\n    function Entry() {}\n\n    Entry.prototype.getData = function (writer, onend, onprogress, checkCrc32) {\n      var that = this;\n\n      function testCrc32(crc32) {\n        var dataCrc32 = getDataHelper(4);\n        dataCrc32.view.setUint32(0, crc32);\n        return that.crc32 == dataCrc32.view.getUint32(0);\n      }\n\n      function getWriterData(uncompressedSize, crc32) {\n        if (checkCrc32 && !testCrc32(crc32)) onerror(ERR_CRC);else writer.getData(function (data) {\n          onend(data);\n        });\n      }\n\n      function onreaderror(err) {\n        onerror(err || ERR_READ_DATA);\n      }\n\n      function onwriteerror(err) {\n        onerror(err || ERR_WRITE_DATA);\n      }\n\n      reader.readUint8Array(that.offset, 30, function (bytes) {\n        var data = getDataHelper(bytes.length, bytes),\n            dataOffset;\n\n        if (data.view.getUint32(0) != 0x504b0304) {\n          onerror(ERR_BAD_FORMAT);\n          return;\n        }\n\n        readCommonHeader(that, data, 4, false, onerror);\n        dataOffset = that.offset + 30 + that.filenameLength + that.extraFieldLength;\n        writer.init(function () {\n          if (that.compressionMethod === 0) copy(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);else inflate(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);\n        }, onwriteerror);\n      }, onreaderror);\n    };\n\n    function seekEOCDR(eocdrCallback) {\n      // \"End of central directory record\" is the last part of a zip archive, and is at least 22 bytes long.\n      // Zip file comment is the last part of EOCDR and has max length of 64KB,\n      // so we only have to search the last 64K + 22 bytes of a archive for EOCDR signature (0x06054b50).\n      var EOCDR_MIN = 22;\n\n      if (reader.size < EOCDR_MIN) {\n        onerror(ERR_BAD_FORMAT);\n        return;\n      }\n\n      var ZIP_COMMENT_MAX = 256 * 256,\n          EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX; // In most cases, the EOCDR is EOCDR_MIN bytes long\n\n      doSeek(EOCDR_MIN, function () {\n        // If not found, try within EOCDR_MAX bytes\n        doSeek(Math.min(EOCDR_MAX, reader.size), function () {\n          onerror(ERR_BAD_FORMAT);\n        });\n      }); // seek last length bytes of file for EOCDR\n\n      function doSeek(length, eocdrNotFoundCallback) {\n        reader.readUint8Array(reader.size - length, length, function (bytes) {\n          for (var i = bytes.length - EOCDR_MIN; i >= 0; i--) {\n            if (bytes[i] === 0x50 && bytes[i + 1] === 0x4b && bytes[i + 2] === 0x05 && bytes[i + 3] === 0x06) {\n              eocdrCallback(new DataView(bytes.buffer, i, EOCDR_MIN));\n              return;\n            }\n          }\n\n          eocdrNotFoundCallback();\n        }, function () {\n          onerror(ERR_READ);\n        });\n      }\n    }\n\n    var zipReader = {\n      getEntries: function (callback) {\n        var worker = this._worker; // look for End of central directory record\n\n        seekEOCDR(function (dataView) {\n          var datalength, fileslength;\n          datalength = dataView.getUint32(16, true);\n          fileslength = dataView.getUint16(8, true);\n\n          if (datalength < 0 || datalength >= reader.size) {\n            onerror(ERR_BAD_FORMAT);\n            return;\n          }\n\n          reader.readUint8Array(datalength, reader.size - datalength, function (bytes) {\n            var i,\n                index = 0,\n                entries = [],\n                entry,\n                filename,\n                comment,\n                data = getDataHelper(bytes.length, bytes);\n\n            for (i = 0; i < fileslength; i++) {\n              entry = new Entry();\n              entry._worker = worker;\n\n              if (data.view.getUint32(index) != 0x504b0102) {\n                onerror(ERR_BAD_FORMAT);\n                return;\n              }\n\n              readCommonHeader(entry, data, index + 6, true, onerror);\n              entry.commentLength = data.view.getUint16(index + 32, true);\n              entry.directory = (data.view.getUint8(index + 38) & 0x10) == 0x10;\n              entry.offset = data.view.getUint32(index + 42, true);\n              filename = getString(data.array.subarray(index + 46, index + 46 + entry.filenameLength));\n              entry.filename = (entry.bitFlag & 0x0800) === 0x0800 ? decodeUTF8(filename) : decodeASCII(filename);\n              if (!entry.directory && entry.filename.charAt(entry.filename.length - 1) == \"/\") entry.directory = true;\n              comment = getString(data.array.subarray(index + 46 + entry.filenameLength + entry.extraFieldLength, index + 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength));\n              entry.comment = (entry.bitFlag & 0x0800) === 0x0800 ? decodeUTF8(comment) : decodeASCII(comment);\n              entries.push(entry);\n              index += 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength;\n            }\n\n            callback(entries);\n          }, function () {\n            onerror(ERR_READ);\n          });\n        });\n      },\n      close: function (callback) {\n        if (this._worker) {\n          this._worker.terminate();\n\n          this._worker = null;\n        }\n\n        if (callback) callback();\n      },\n      _worker: null\n    };\n    if (!obj.zip.useWebWorkers) callback(zipReader);else {\n      createWorker('inflater', function (worker) {\n        zipReader._worker = worker;\n        callback(zipReader);\n      }, function (err) {\n        onerror(err);\n      });\n    }\n  } // ZipWriter\n\n\n  function encodeUTF8(string) {\n    return unescape(encodeURIComponent(string));\n  }\n\n  function getBytes(str) {\n    var i,\n        array = [];\n\n    for (i = 0; i < str.length; i++) array.push(str.charCodeAt(i));\n\n    return array;\n  }\n\n  function createZipWriter(writer, callback, onerror, dontDeflate) {\n    var files = {},\n        filenames = [],\n        datalength = 0;\n    var deflateSN = 0;\n\n    function onwriteerror(err) {\n      onerror(err || ERR_WRITE);\n    }\n\n    function onreaderror(err) {\n      onerror(err || ERR_READ_DATA);\n    }\n\n    var zipWriter = {\n      add: function (name, reader, onend, onprogress, options) {\n        var header, filename, date;\n        var worker = this._worker;\n\n        function writeHeader(callback) {\n          var data;\n          date = options.lastModDate || new Date();\n          header = getDataHelper(26);\n          files[name] = {\n            headerArray: header.array,\n            directory: options.directory,\n            filename: filename,\n            offset: datalength,\n            comment: getBytes(encodeUTF8(options.comment || \"\"))\n          };\n          header.view.setUint32(0, 0x14000808);\n          if (options.version) header.view.setUint8(0, options.version);\n          if (!dontDeflate && options.level !== 0 && !options.directory) header.view.setUint16(4, 0x0800);\n          header.view.setUint16(6, (date.getHours() << 6 | date.getMinutes()) << 5 | date.getSeconds() / 2, true);\n          header.view.setUint16(8, (date.getFullYear() - 1980 << 4 | date.getMonth() + 1) << 5 | date.getDate(), true);\n          header.view.setUint16(22, filename.length, true);\n          data = getDataHelper(30 + filename.length);\n          data.view.setUint32(0, 0x504b0304);\n          data.array.set(header.array, 4);\n          data.array.set(filename, 30);\n          datalength += data.array.length;\n          writer.writeUint8Array(data.array, callback, onwriteerror);\n        }\n\n        function writeFooter(compressedLength, crc32) {\n          var footer = getDataHelper(16);\n          datalength += compressedLength || 0;\n          footer.view.setUint32(0, 0x504b0708);\n\n          if (typeof crc32 != \"undefined\") {\n            header.view.setUint32(10, crc32, true);\n            footer.view.setUint32(4, crc32, true);\n          }\n\n          if (reader) {\n            footer.view.setUint32(8, compressedLength, true);\n            header.view.setUint32(14, compressedLength, true);\n            footer.view.setUint32(12, reader.size, true);\n            header.view.setUint32(18, reader.size, true);\n          }\n\n          writer.writeUint8Array(footer.array, function () {\n            datalength += 16;\n            onend();\n          }, onwriteerror);\n        }\n\n        function writeFile() {\n          options = options || {};\n          name = name.trim();\n          if (options.directory && name.charAt(name.length - 1) != \"/\") name += \"/\";\n\n          if (files.hasOwnProperty(name)) {\n            onerror(ERR_DUPLICATED_NAME);\n            return;\n          }\n\n          filename = getBytes(encodeUTF8(name));\n          filenames.push(name);\n          writeHeader(function () {\n            if (reader) {\n              if (dontDeflate || options.level === 0) copy(worker, deflateSN++, reader, writer, 0, reader.size, true, writeFooter, onprogress, onreaderror, onwriteerror);else deflate(worker, deflateSN++, reader, writer, options.level, writeFooter, onprogress, onreaderror, onwriteerror);\n            } else writeFooter();\n          }, onwriteerror);\n        }\n\n        if (reader) reader.init(writeFile, onreaderror);else writeFile();\n      },\n      close: function (callback) {\n        if (this._worker) {\n          this._worker.terminate();\n\n          this._worker = null;\n        }\n\n        var data,\n            length = 0,\n            index = 0,\n            indexFilename,\n            file;\n\n        for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {\n          file = files[filenames[indexFilename]];\n          length += 46 + file.filename.length + file.comment.length;\n        }\n\n        data = getDataHelper(length + 22);\n\n        for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {\n          file = files[filenames[indexFilename]];\n          data.view.setUint32(index, 0x504b0102);\n          data.view.setUint16(index + 4, 0x1400);\n          data.array.set(file.headerArray, index + 6);\n          data.view.setUint16(index + 32, file.comment.length, true);\n          if (file.directory) data.view.setUint8(index + 38, 0x10);\n          data.view.setUint32(index + 42, file.offset, true);\n          data.array.set(file.filename, index + 46);\n          data.array.set(file.comment, index + 46 + file.filename.length);\n          index += 46 + file.filename.length + file.comment.length;\n        }\n\n        data.view.setUint32(index, 0x504b0506);\n        data.view.setUint16(index + 8, filenames.length, true);\n        data.view.setUint16(index + 10, filenames.length, true);\n        data.view.setUint32(index + 12, length, true);\n        data.view.setUint32(index + 16, datalength, true);\n        writer.writeUint8Array(data.array, function () {\n          writer.getData(callback);\n        }, onwriteerror);\n      },\n      _worker: null\n    };\n    if (!obj.zip.useWebWorkers) callback(zipWriter);else {\n      createWorker('deflater', function (worker) {\n        zipWriter._worker = worker;\n        callback(zipWriter);\n      }, function (err) {\n        onerror(err);\n      });\n    }\n  }\n\n  function resolveURLs(urls) {\n    var a = document.createElement('a');\n    return urls.map(function (url) {\n      a.href = url;\n      return a.href;\n    });\n  }\n\n  var DEFAULT_WORKER_SCRIPTS = {\n    deflater: ['z-worker.js', 'deflate.js'],\n    inflater: ['z-worker.js', 'inflate.js']\n  };\n\n  function createWorker(type, callback, onerror) {\n    if (obj.zip.workerScripts !== null && obj.zip.workerScriptsPath !== null) {\n      onerror(new Error('Either zip.workerScripts or zip.workerScriptsPath may be set, not both.'));\n      return;\n    }\n\n    var scripts;\n\n    if (obj.zip.workerScripts) {\n      scripts = obj.zip.workerScripts[type];\n\n      if (!Array.isArray(scripts)) {\n        onerror(new Error('zip.workerScripts.' + type + ' is not an array!'));\n        return;\n      }\n\n      scripts = resolveURLs(scripts);\n    } else {\n      scripts = DEFAULT_WORKER_SCRIPTS[type].slice(0);\n      scripts[0] = (obj.zip.workerScriptsPath || '') + scripts[0];\n    }\n\n    var worker = new Worker(scripts[0]); // record total consumed time by inflater/deflater/crc32 in this worker\n\n    worker.codecTime = worker.crcTime = 0;\n    worker.postMessage({\n      type: 'importScripts',\n      scripts: scripts.slice(1)\n    });\n    worker.addEventListener('message', onmessage);\n\n    function onmessage(ev) {\n      var msg = ev.data;\n\n      if (msg.error) {\n        worker.terminate(); // should before onerror(), because onerror() may throw.\n\n        onerror(msg.error);\n        return;\n      }\n\n      if (msg.type === 'importScripts') {\n        worker.removeEventListener('message', onmessage);\n        worker.removeEventListener('error', errorHandler);\n        callback(worker);\n      }\n    } // catch entry script loading error and other unhandled errors\n\n\n    worker.addEventListener('error', errorHandler);\n\n    function errorHandler(err) {\n      worker.terminate();\n      onerror(err);\n    }\n  }\n\n  function onerror_default(error) {\n    console.error(error);\n  }\n\n  obj.zip = {\n    Reader: Reader,\n    Writer: Writer,\n    BlobReader: BlobReader,\n    Data64URIReader: Data64URIReader,\n    TextReader: TextReader,\n    BlobWriter: BlobWriter,\n    Data64URIWriter: Data64URIWriter,\n    TextWriter: TextWriter,\n    createReader: function (reader, callback, onerror) {\n      onerror = onerror || onerror_default;\n      reader.init(function () {\n        createZipReader(reader, callback, onerror);\n      }, onerror);\n    },\n    createWriter: function (writer, callback, onerror, dontDeflate) {\n      onerror = onerror || onerror_default;\n      dontDeflate = !!dontDeflate;\n      writer.init(function () {\n        createZipWriter(writer, callback, onerror, dontDeflate);\n      }, onerror);\n    },\n    useWebWorkers: true,\n\n    /**\n     * Directory containing the default worker scripts (z-worker.js, deflate.js, and inflate.js), relative to current base url.\n     * E.g.: zip.workerScripts = './';\n     */\n    workerScriptsPath: null,\n\n    /**\n     * Advanced option to control which scripts are loaded in the Web worker. If this option is specified, then workerScriptsPath must not be set.\n     * workerScripts.deflater/workerScripts.inflater should be arrays of urls to scripts for deflater/inflater, respectively.\n     * Scripts in the array are executed in order, and the first one should be z-worker.js, which is used to start the worker.\n     * All urls are relative to current base url.\n     * E.g.:\n     * zip.workerScripts = {\n     *   deflater: ['z-worker.js', 'deflate.js'],\n     *   inflater: ['z-worker.js', 'inflate.js']\n     * };\n     */\n    workerScripts: null\n  };\n})(this);\n\n//# sourceURL=webpack:///./lib/zip.js?");

/***/ })

/******/ });
});